import{_ as Mt,O as ea,K as ta,r as z,u as aa,P as mt,o as ct,g as H,Q as te,y as _,C as S,B as g,z as I,x as L,S as _e,T as ke,R as V,A as se,D as R,L as It,a0 as Ba,N as Ha,W as Wa,X as qa,k as Je,s as Ga,e as Ua,U as ye,a1 as Ka,a2 as Ja,J as Ya}from"./vCgPr7MF.js";import{R as ge,I as Za}from"./Bft2VglB.js";import{I as Xa}from"./Cst-e0XL.js";import{_ as Qa,a as j,e as dt,g as Ma,c as es,I as sa,b as ts,i as as,m as ss,o as de,d as rs,E as oe,F as Et,f as K,h as Xe,A as ns,B as is,D as os,L as us,M as ls,r as ae,j as ps,T as At,w as ms,v as cs,S as ds,k as fs,G as hs,s as ys,l as ra,n as na,p as gs,q as bs,t as Ns,u as vs,x as Ts,y as Ss,z as $t,C as Dt,H as ws,J as _s,K as ks,N as Os,O as Is,P as Es,Q as As,R as be,U as $s,V as Ds,W as Ps,X as zs,Y as Cs,Z as xs,$ as Vs,a0 as Ls,a1 as Fs,a2 as js,a3 as Rs,a4 as Bs,a5 as ia,a6 as Hs,a7 as Ws,a8 as qs,a9 as Gs,aa as Us,ab as Ks,ac as Js,ad as Ys,ae as Zs,af as Xs,ag as Qs,ah as Ms,ai as er,aj as tr,ak as ar,al as sr,am as rr,an as nr,ao as ir,ap as or,aq as ur,ar as lr,as as pr,at as mr,au as cr,av as dr,aw as fr,ax as hr,ay as yr,az as gr,aA as br,aB as Nr,aC as vr,aD as Tr,aE as Sr,aF as wr,aG as _r,aH as kr,aI as Te,aJ as we,aK as Be,aL as Le,aM as ft,aN as Fe,aO as W,aP as ht,aQ as Or,aR as Ir,aS as Er,aT as Ar,aU as $r,aV as Dr,aW as Pr,aX as zr,aY as Cr,aZ as xr,a_ as Vr,a$ as oa,b0 as Lr,b1 as Fr,b2 as jr,b3 as Rr,b4 as Br,b5 as Hr,b6 as Wr,b7 as Ve,b8 as Oe,b9 as Pt,ba as qr,bb as zt,bc as Gr,bd as Ur,be as Kr,bf as Jr,bg as Yr,bh as Zr,bi as Xr,bj as Qr,bk as Mr,bl as en,bm as tn,bn as an,bo as sn,bp as rn,bq as nn,br as on,bs as Ct,bt as un,bu as ln,bv as pn,bw as mn,bx as cn,by as dn,bz as fn,bA as hn,bB as yn,bC as gn,bD as bn,bE as Qe,bF as Nn,bG as xt,bH as Vt,bI as vn,bJ as Tn,bK as Sn,bL as wn,bM as _n,bN as kn,bO as On,bP as In,bQ as En,bR as An,bS as $n,bT as Me,bU as Dn,bV as Pn,bW as zn,bX as ua,bY as Ye,bZ as Cn,b_ as Lt,b$ as xn}from"./CCAxohpf.js";import{G as Ft}from"./CI608YEO.js";const Vn={class:"mt-3"},Ln={style:{"font-size":"1.6em"}},Fn={key:0,style:{"font-size":"1.3em","font-style":"italic"},class:"ml-4"},jn={__name:"TimerDialog",emits:["result"],setup(a,{emit:e}){ea();const t=ta();z(t.authInfo);const s=e;aa(),mt().params.userId;const n=z(!1),o=z(null),u=z(null),l=z(!1),p=z([]);let c=null;ct(async()=>{s("result",async y=>(p.value=y,l.value=!1,c=new Audio("/audio/alert.mp3"),c.loop=!0,c.play(),setTimeout(()=>{f()},1e4),n.value=!0,new Promise((b,N)=>{o.value=b,u.value=N})))});function f(){c&&(c.pause(),c.currentTime=0,l.value=!0)}function d(){f(),n.value=!1,o.value(!1)}return(y,b)=>{const N=H("v-card-title"),v=H("v-divider"),B=H("v-card-text"),J=H("v-btn"),C=H("v-card-actions"),fe=H("v-card"),ne=H("v-dialog");return _(),te(ne,{"max-width":"600",persistent:"",modelValue:n.value,"onUpdate:modelValue":b[0]||(b[0]=F=>n.value=F)},{default:S(()=>[g(fe,{style:{"background-color":"#fcfaf7"},class:"pa-4"},{default:S(()=>[g(N,null,{default:S(()=>[...b[1]||(b[1]=[I("h2",null,"Zeit abgelaufen!",-1)])]),_:1}),g(B,null,{default:S(()=>[b[3]||(b[3]=I("div",{style:{width:"100%"},class:"text-center"},[I("div",{class:"vibrate"},[I("img",{alt:"bellring",src:Qa,style:{width:"300px",height:"300px"},class:"mt-2"})])],-1)),g(v),I("div",Vn,[b[2]||(b[2]=I("h3",null,"Folgende Timer sind abgelaufen:",-1)),(_(!0),L(_e,null,ke(p.value,F=>(_(),L("div",{key:F.id},[I("span",Ln,"- "+se(F.title),1),F.descriptionTextAfter?(_(),L("div",Fn,se(F.descriptionTextAfter),1)):V("",!0)]))),128))])]),_:1}),g(C,null,{default:S(()=>[g(J,{onClick:f,rounded:"",variant:"outlined",disabled:l.value},{default:S(()=>[...b[4]||(b[4]=[R(" Wecker stoppen ",-1)])]),_:1},8,["disabled"]),g(J,{onClick:d,rounded:"",variant:"outlined",color:"red"},{default:S(()=>[...b[5]||(b[5]=[R(" SchlieÃŸen ",-1)])]),_:1})]),_:1})]),_:1})]),_:1},8,["modelValue"])}}},Rn=Mt(jn,[["__scopeId","data-v-38b0a021"]]);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(a,e,t,s){o(a),t=t??0,s=s??1,u(t,s);let i=0;const n=l=>(l.then(p=>{const c=t+ ++i/a.length*(s-t);return e(c),p}),l);function o(l){j(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function u(l,p){j(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),j(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),j(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}return Promise.all(a.map(n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Bn(a,e){e==null&&(e={});const t=e.fetchFunc==null?dt().platform.fetch:e.fetchFunc,s=a.map(f=>t(f,e.requestInit,{isBinary:!0})),u=(e.onProgress==null?await Promise.all(s):await jt(s,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(u):await jt(u,e.onProgress,.5,1)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn="application/octet-stream",Wn="application/json";class yt{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(j(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=dt().platform.fetch,j(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&j(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:s};e.signature!=null&&(i.signature=e.signature),e.userDefinedMetadata!=null&&(i.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(i.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(i)],{type:Wn}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Hn}),"model.weights.bin");const n=await this.fetch(this.path,t);if(n.ok)return{modelArtifactsInfo:Ma(e),responses:[n]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${n.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let N=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?N+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":N+=" Please make sure the server is serving valid JSON for this request.",new Error(N)}const s=t.modelTopology,i=t.weightsManifest,n=t.generatedBy,o=t.convertedBy,u=t.format,l=t.signature,p=t.userDefinedMetadata;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let c,f;i!=null&&([c,f]=await this.loadWeights(i));const d={modelTopology:s,weightSpecs:c,weightData:f,generatedBy:n,convertedBy:o,format:u};l!=null&&(d.signature=l),p!=null&&(d.userDefinedMetadata=p);const y=t.modelInitializer;return y&&(d.modelInitializer=y),d}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=qn(t),n=this.weightPathPrefix||s,o=[];for(const c of e)o.push(...c.weights);const u=[],l=[];for(const c of e)for(const f of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(f)):u.push(n+f+i);this.weightUrlConverter&&u.push(...await Promise.all(l));const p=await Bn(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,es(p)]}}yt.URL_SCHEME_REGEX=/^https?:\/\//;function qn(a){const e=a.lastIndexOf("/"),t=a.lastIndexOf("?"),s=a.substring(0,e),i=t>e?a.substring(t):"";return[s+"/",i]}function Rt(a){return a.match(yt.URL_SCHEME_REGEX)!=null}const la=(a,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(a)?t=a.every(s=>Rt(s)):t=Rt(a),t)return pa(a,e)}return null};sa.registerSaveRouter(la);sa.registerLoadRouter(la);function pa(a,e){return new yt(a,e)}function Bt(a,e){return pa(a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gn(a,e,t){if(ts(a),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=as(a,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ss(a,e,s,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pe;function Un(a,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(a==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,n=!1,o=!1,u=!1;if(a.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&a instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement)n=!0;else if(a.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&a instanceof ImageBitmap)u=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${a.constructor.name}`);if(i&&i&&a.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(rs(Et,oe.backendName)!=null){const b={pixels:a},N={numChannels:e};return oe.runKernel(Et,b,N)}const[p,c]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height];let f;o?f=a.getContext("2d").getImageData(0,0,p,c).data:s||t?f=a.data:(n||i||u)&&(Pe==null&&(Pe=document.createElement("canvas").getContext("2d")),Pe.canvas.width=p,Pe.canvas.height=c,Pe.drawImage(a,0,0,p,c),f=Pe.getImageData(0,0,p,c).data);let d;if(e===4)d=new Int32Array(f);else{const b=p*c;d=new Int32Array(b*e);for(let N=0;N<b;N++)for(let v=0;v<e;++v)d[N*e+v]=f[N*4+v]}return Gn(d,[c,p,e],"int32")}const Kn=de({fromPixels_:Un});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jn(a){j(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),j(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);const e=a.map((i,n)=>K(i,`tensors${n}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Xe(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return oe.runKernel(ns,s)}const Yn=de({addN_:Jn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zn(a,e,t){const s=K(a,"x","bincount"),i=K(e,"weights","bincount");j(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),j(t>=0,()=>`size must be non-negative, but got ${t}.`),j(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const n={x:s,weights:i},o={size:t};return oe.runKernel(is,n,o)}const Xn=de({bincount_:Zn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(a,e,t,s=!1){const i=K(a,"x","denseBincount"),n=K(e,"weights","denseBincount");j(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),j(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),j(t>=0,()=>`size must be non-negative, but got ${t}.`),j(n.size===i.size||n.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${n.shape}.`);const o={x:i,weights:n},u={size:t,binaryOutput:s};return oe.runKernel(os,o,u)}const Mn=de({denseBincount_:Qn});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(a,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:a,stop:e,num:t};return oe.runKernel(us,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(a,e,t,s,i=!1){const o={x:K(a,"x","maxPoolWithArgmax")},u={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},l=oe.runKernel(ls,o,u);return{result:l[0],indexes:l[1]}}const ai=de({maxPoolWithArgmax_:ti});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function si(a,e,t,s=!1){const i=K(a,"logits","multinomial"),n=i.size,o=i.rank;if(n<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${n}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ae(i,[1,-1]):i},p={numSamples:e,seed:t,normalized:s},c=oe.runKernel(ps,l,p);return o===1?ae(c,[c.size]):c}const ri=de({multinomial_:si});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ni(a,e){const t=K(a,"x","setdiff1d"),s=K(e,"y","setdiff1d");j(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),j(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),j(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),n=await s.data(),o=new Set(n);let u=0;for(let c=0;c<i.length;c++)o.has(i[c])||u++;const l=new At([u],t.dtype),p=new At([u],"int32");for(let c=0,f=0;c<i.length;c++)o.has(i[c])||(l.values[f]=i[c],p.values[f]=c,f++);return[l.toTensor(),p.toTensor()]}const ii=ni;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function oi(a){const e=K(a,"condition","whereAsync","bool"),t=await e.data(),s=ms(e.shape,t);return a!==e&&e.dispose(),s}const ui=oi;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function li(a,e,t){const s=K(a,"indices","scatterND","int32"),i=K(e,"updates","scatterND");cs(i,s,t);const n={indices:s,updates:i},o={shape:t};return oe.runKernel(ds,n,o)}const pi=de({scatterND_:li});function mi(a,e,t,s){if(a.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);const i=a.rank>0?a.shape[0]:1,n=a.rank>1?a.shape[1]:1;if(t.length!==n)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${n}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ci(a,e,t,s=0){const i=K(a,"sparseIndices","sparseToDense","int32"),n=K(e,"sparseValues","sparseToDense"),o=K(s,"defaultValue","sparseToDense",n.dtype);mi(i,n,t,o);const u={sparseIndices:i,sparseValues:n,defaultValue:o},l={outputShape:t};return oe.runKernel(fs,u,l)}const ma=de({sparseToDense_:ci});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function di(a,e){const t=K(e,"indices","gatherND","int32"),i={params:K(a,"x","gatherND"),indices:t};return oe.runKernel(hs,i)}const fi=de({gatherND_:di});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi({x:a,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:n=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:c}){if(ys(oe.state.gradientDepth,l)===!1){let ne=ra(a,e,t,s,i,n,o);return u!=null&&(ne=na(ne,u)),gs(ne,l,p,c)}const f=K(a,"x","depthwiseConv2d"),d=K(e,"filter","depthwiseConv2d");let y=f,b=!1;f.rank===3&&(b=!0,y=ae(f,[1,f.shape[0],f.shape[1],f.shape[2]])),j(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),j(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),j(y.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),n==null&&(n=[1,1]),j(bs(t,n),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${n}'`),o!=null&&j(Ns(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const N=vs(y.shape,d.shape,t,n,s,o,!0);let v;u!=null&&(v=K(u,"bias","fused conv2d"),[v]=Ts(v,f),Ss(N.outShape,v.shape));let B;p!=null&&(B=K(p,"prelu weights","fused depthwiseConv2d"));const J=(ne,F)=>{j(ws(n),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${n}'`);const[pe,q,Y,X]=F,Ie=_s(ne,Y,l),M=ks(q.shape,Ie,pe,t,s,n,o),Ce=Os(q,Ie,pe.shape,t,s,n,o);if(X!=null){const Ee=Is(v,Ie);return[M,Ce,Ee]}return[M,Ce]},C={x:y,filter:d,bias:v,preluActivationWeights:B},fe={strides:t,pad:s,dataFormat:i,dilations:n,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return u==null?$t((F,pe,q)=>{let Y=oe.runKernel(Dt,C,fe);return q([pe,F,Y]),b&&(Y=ae(Y,[Y.shape[1],Y.shape[2],Y.shape[3]])),{value:Y,gradFunc:J}})(y,d):$t((F,pe,q,Y)=>{let X=oe.runKernel(Dt,C,fe);return Y([pe,F,X,q]),b&&(X=ae(X,[X.shape[1],X.shape[2],X.shape[3]])),{value:X,gradFunc:J}})(y,d,v)}const yi=de({fusedDepthwiseConv2d_:hi});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gi={};function ca(a){return gi[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,e,t,s,i){const n=e.inputParams[a];if(n&&n.inputIndexStart!==void 0){const u=n.inputIndexStart,l=n.inputIndexEnd===0?void 0:n.inputIndexEnd===void 0?u+1:n.inputIndexEnd;if(n.type==="tensor")return re(e.inputNames[n.inputIndexStart],t,s,i);if(n.type==="tensors")return e.inputNames.slice(u,l).map(d=>re(d,t,s,i));const p=re(e.inputNames.slice(u)[0],t,s,i),c=p.dataSync();return n.type==="number"?c[0]:Es(p.shape,c)}const o=e.attrParams[a];return o&&o.value}function re(a,e,t,s){const[i,n]=ie(a);if(s!=null){const u=s.getHashTableHandleByName(i);if(u!=null)return u}const o=t.currentContextIds.find(u=>!!e[He(i,u)]);return o!==void 0?e[He(i,o)][n]:void 0}function bi(a,e,t){return e[He(a,t.currentContextId)]}function Ne(a,e){const[t,s]=ie(a);return[He(t,e&&e.currentContextId),s]}function He(a,e){return e?`${a}-${e}`:a}function ie(a){const e=a.split(":");return e.length===1?[a,0]:[e[0],Number(e[e.length-1])]}function Re(a,e,t){let s=r("pad",a,e,t);if(s==="explicit"){s=r("explicitPaddings",a,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let n=0;n<4;n++)i[n][0]=s[n*2],i[n][1]=s[n*2+1];return i}return s}function ve(a){return a.kept?a:As(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vi=Object.freeze(Object.defineProperty({__proto__:null,json:Ni},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ti=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Si=Object.freeze(Object.defineProperty({__proto__:null,json:Ti},Symbol.toStringTag,{value:"Module"})),wi=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],_i=Object.freeze(Object.defineProperty({__proto__:null,json:wi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ki=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Oi=Object.freeze(Object.defineProperty({__proto__:null,json:ki},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ii=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ei=Object.freeze(Object.defineProperty({__proto__:null,json:Ii},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ai=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$i=Object.freeze(Object.defineProperty({__proto__:null,json:Ai},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Di=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Pi=Object.freeze(Object.defineProperty({__proto__:null,json:Di},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zi=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ci=Object.freeze(Object.defineProperty({__proto__:null,json:zi},Symbol.toStringTag,{value:"Module"})),xi=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Vi=Object.freeze(Object.defineProperty({__proto__:null,json:xi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Li=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Fi=Object.freeze(Object.defineProperty({__proto__:null,json:Li},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ji=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ri=Object.freeze(Object.defineProperty({__proto__:null,json:ji},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bi=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Hi=Object.freeze(Object.defineProperty({__proto__:null,json:Bi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wi=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],qi=Object.freeze(Object.defineProperty({__proto__:null,json:Wi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gi=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ui=Object.freeze(Object.defineProperty({__proto__:null,json:Gi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ki=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Ji=Object.freeze(Object.defineProperty({__proto__:null,json:Ki},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yi=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Zi=Object.freeze(Object.defineProperty({__proto__:null,json:Yi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xi=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}],Qi=Object.freeze(Object.defineProperty({__proto__:null,json:Xi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ht{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[vi,Si,_i,Oi,Ei,$i,Pi,Ri,Fi,Ci,Hi,qi,Ui,Ji,Zi,Qi,Vi],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(e,t={}){const s=e.node,i=[],n=[],o=[],u=s.reduce((N,v)=>(N[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?i.push(N[v.name]):v.op==="Const"?n.push(N[v.name]):(v.input==null||v.input.length===0)&&o.push(N[v.name]),N),{});let l=[];const p=[];let c={},f={};t!=null&&(c=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const d=Object.keys(u);d.forEach(N=>{const v=u[N];v.inputNames.forEach(B=>{const[J]=Ne(B);v.inputs.push(u[J]),u[J].children.push(v)})}),Object.keys(f).length===0?d.forEach(N=>{const v=u[N];v.children.length===0&&p.push(v)}):Object.keys(f).forEach(N=>{const[v]=Ne(N),B=u[v];B!=null&&(B.signatureKey=f[N],p.push(B))}),Object.keys(c).length>0?Object.keys(c).forEach(N=>{const[v]=Ne(N),B=u[v];B&&(B.signatureKey=c[N],l.push(B))}):l=i;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((N,v)=>(N[v.signature.name]=this.mapFunction(v),N),{}));const b={nodes:u,inputs:l,outputs:p,weights:n,placeholders:i,signature:t,functions:y};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=ca(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.substr(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,n)=>(i[n.name]={type:n.type,inputIndexStart:n.start,inputIndexEnd:n.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,n)=>{const o=n.type;let u;switch(n.type){case"string":u=et(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=et(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":u=ot(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ot(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":u=at(e.attr,n.tfName,n.defaultValue||0),u===void 0&&n.tfDeprecatedName&&(u=at(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":u=it(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=it(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":u=tt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=tt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":u=lt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=lt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":u=nt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=nt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":u=ut(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ut(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":u=st(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=st(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":u=rt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=rt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":u=Wt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=Wt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return i[n.name]={value:u,type:o},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let n={};t!=null&&(n=t.reduce((f,d)=>(f[d.name]=this.mapNode(d),d.op==="Const"&&i.push(f[d.name]),f),{}));const o=[],u=[];e.signature.inputArg.forEach(f=>{const[d]=Ne(f.name),y={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:gt(f.type),type:"dtype"}},children:[]};y.signatureKey=f.name,o.push(y),n[d]=y}),Object.keys(n).forEach(f=>{const d=n[f];d.inputNames.forEach(y=>{const[b]=Ne(y);d.inputs.push(n[b]),n[b].children.push(d)})});const p=e.ret;e.signature.outputArg.forEach(f=>{const[d,y]=Ne(p[f.name]),b=n[d];b!=null&&(b.defaultOutput=y,u.push(b))});const c=this.mapArgsToSignature(e);return{nodes:n,inputs:o,outputs:u,weights:i,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Mi(a){const e=dt().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function da(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):Mi(a);return e?t:t.toLowerCase()}function et(a,e,t,s=!1){const i=a[e];return i!=null?da(i.s,s):t}function tt(a,e,t){const s=a[e];return s?s.b:t}function at(a,e,t){const s=a[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function gt(a){switch(typeof a=="string"&&(a=be[a]),a){case be.DT_FLOAT:return"float32";case be.DT_INT32:case be.DT_INT64:case be.DT_INT8:case be.DT_UINT8:return"int32";case be.DT_BOOL:return"bool";case be.DT_DOUBLE:return"float32";case be.DT_STRING:return"string";default:return null}}function Wt(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function st(a,e,t){const s=a[e];return s&&s.type?gt(s.type):t}function rt(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(i=>gt(i)):t}function fa(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function nt(a,e,t){const s=a[e];return s&&s.shape?fa(s.shape):t}function it(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function ot(a,e,t,s=!1){const i=a[e];return i&&i.list&&i.list.s?i.list.s.map(n=>da(n,s)):t}function ut(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>fa(i)):t}function lt(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eo{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,n)=>(i[n]=this.getAttr(n),i),{}))}getInput(e){return re(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return re(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return at(this.node.rawAttrs,e,t);if(s.s!=null)return et(this.node.rawAttrs,e,t);if(s.b!=null)return tt(this.node.rawAttrs,e,t);if(s.shape!=null)return nt(this.node.rawAttrs,e,t);if(s.type!=null)return st(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return it(this.node.rawAttrs,e,t);if(s.list.s!=null)return ot(this.node.rawAttrs,e,t);if(s.list.shape!=null)return ut(this.node.rawAttrs,e,t);if(s.list.b!=null)return lt(this.node.rawAttrs,e,t);if(s.list.type!=null)return rt(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const to=(a,e,t)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[na(r("a",a,e,t),r("b",a,e,t))];case"AddN":return[Yn(r("tensors",a,e,t))];case"FloorMod":case"Mod":return[js(r("a",a,e,t),r("b",a,e,t))];case"Mul":return[Fs(r("a",a,e,t),r("b",a,e,t))];case"RealDiv":case"Div":return[Ls(r("a",a,e,t),r("b",a,e,t))];case"DivNoNan":return[Vs(r("a",a,e,t),r("b",a,e,t))];case"FloorDiv":return[xs(r("a",a,e,t),r("b",a,e,t))];case"Sub":return[Cs(r("a",a,e,t),r("b",a,e,t))];case"Minimum":return[zs(r("a",a,e,t),r("b",a,e,t))];case"Maximum":return[Ps(r("a",a,e,t),r("b",a,e,t))];case"Pow":return[Ds(r("a",a,e,t),r("b",a,e,t))];case"SquaredDifference":return[$s(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao=(a,e,t)=>{switch(a.op){case"Abs":case"ComplexAbs":return[kr(r("x",a,e,t))];case"Acos":return[_r(r("x",a,e,t))];case"Acosh":return[wr(r("x",a,e,t))];case"Asin":return[Sr(r("x",a,e,t))];case"Asinh":return[Tr(r("x",a,e,t))];case"Atan":return[vr(r("x",a,e,t))];case"Atan2":return[Nr(r("x",a,e,t),r("y",a,e,t))];case"Atanh":return[br(r("x",a,e,t))];case"Ceil":return[gr(r("x",a,e,t))];case"Complex":return[yr(r("real",a,e,t),r("imag",a,e,t))];case"Cos":return[hr(r("x",a,e,t))];case"Cosh":return[fr(r("x",a,e,t))];case"Elu":return[dr(r("x",a,e,t))];case"Erf":return[cr(r("x",a,e,t))];case"Exp":return[mr(r("x",a,e,t))];case"Expm1":return[pr(r("x",a,e,t))];case"Floor":return[lr(r("x",a,e,t))];case"Log":return[ur(r("x",a,e,t))];case"Log1p":return[or(r("x",a,e,t))];case"Imag":return[ir(r("x",a,e,t))];case"Neg":return[nr(r("x",a,e,t))];case"Reciprocal":return[rr(r("x",a,e,t))];case"Real":return[sr(r("x",a,e,t))];case"Relu":return[ar(r("x",a,e,t))];case"Round":return[tr(r("x",a,e,t))];case"Selu":return[er(r("x",a,e,t))];case"Sigmoid":return[Ms(r("x",a,e,t))];case"Sin":return[Qs(r("x",a,e,t))];case"Sign":return[Xs(r("x",a,e,t))];case"Sinh":return[Zs(r("x",a,e,t))];case"Softplus":return[Ys(r("x",a,e,t))];case"Sqrt":return[Js(r("x",a,e,t))];case"Square":return[Ks(r("x",a,e,t))];case"Tanh":return[Us(r("x",a,e,t))];case"Tan":return[Gs(r("x",a,e,t))];case"ClipByValue":return[qs(r("x",a,e,t),r("clipValueMin",a,e,t),r("clipValueMax",a,e,t))];case"Relu6":return[Ws(r("x",a,e,t))];case"Rsqrt":return[Hs(re(a.inputNames[0],e,t))];case"Prod":return[ia(r("x",a,e,t),r("axes",a,e,t))];case"LeakyRelu":return[Bs(r("x",a,e,t),r("alpha",a,e,t))];case"Prelu":return[Rs(r("x",a,e,t),r("alpha",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function le(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){j(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const i=a[s],n=e[s];j(i<0||n<0||i===n,()=>t+` Shapes ${a} and ${e} must match`)}}}function qt(a){return!(typeof a=="number"||a.some(e=>e<0))}function xe(a,e,t){let s=pt(a,t);const i=!qt(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(n=>{s=pt(n.shape,s)}),!qt(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function pt(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const i=a[s],n=e[s];if(i>=0&&n>=0&&i!==n)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=i>=0?i:n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class so{constructor(e,t,s,i,n,o,u){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=n,this.dynamicSize=o,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=Te(0),we(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),le(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,we(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Be([],[0].concat(this.elementShape));const s=this.readMany(e);return le(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Le(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Be([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return le(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ft(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Fe(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const n=s===0?0:t.size/s,o=[];W(()=>{t=ae(t,[1,s,n]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],f=[1,e[l],n];o[l]=ae(ht(t,c,f),this.elementShape)}return o});const u=[];for(let l=0;l<e.length;l++)u[l]=l;this.writeMany(u,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ze{constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(n=>{if(s!==n.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${n.dtype}`);le(t,n.shape,"TensorList shape mismatch: "),we(n)}),this.idTensor=Te(0),this.maxNumElements=i,we(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ze([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);le(e,this.elementShape,"TensorList shape mismatch: ");const i=xe(this.elementShape,this.tensors,e);return W(()=>{const n=this.tensors.map(o=>ae(o,i));return Le(n,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=xe(this.elementShape,this.tensors,e),i=this.tensors.pop();return le(i.shape,e,"TensorList shape mismatch: "),ae(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(le(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");we(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);le(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=xe(this.elementShape,this.tensors,t);return ae(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);le(this.elementShape,t.shape,"TensorList shape mismatch: "),we(t),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);le(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=xe(this.elementShape,this.tensors,s);return e.length===0?Be([],[0].concat(i)):W(()=>{const n=e.map(o=>ae(this.tensors[o],i));return Le(n,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);le(this.elementShape,t,"TensorList shape mismatch: ");const s=xe(this.elementShape,this.tensors,t);return this.size()===0?Be([],[0].concat(s)):W(()=>{const i=this.tensors.map(n=>ae(n,s));return ft(i,0)})}}function ro(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const i=a.shape.slice(1);le(i,e,"TensorList shape mismatch: ");const n=Fe(a);return new ze(n,e,s)}function no(a,e,t){return new ze([],a,e,t)}function io(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const n=new ze([],t,a.dtype,s),o=Fe(a,0);return e.forEach((u,l)=>{n.setItem(u,o[l])}),n}function oo(a,e,t){let s=0;const i=e.map(c=>(s+=c,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const n=a.shape.slice(1),o=pt(n,t),u=s===0?0:a.size/s,l=W(()=>{const c=[];a=ae(a,[1,s,u]);for(let f=0;f<e.length;++f){const y=[0,f===0?0:i[f-1],0],b=[1,e[f],u];c[f]=ae(ht(a,y,b),o)}return a.dispose(),c}),p=new ze([],t,a.dtype,e.length);for(let c=0;c<l.length;c++)p.setItem(c,l[c]);return p}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uo=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=r("thenBranch",a,e,t),i=r("elseBranch",a,e,t),n=r("cond",a,e,t),o=r("args",a,e,t);return(await n.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=r("body",a,e,t),i=r("cond",a,e,t),n=r("args",a,e,t),o=await t.functionMap[i].executeFunctionAsync(n,t.tensorArrayMap,t.tensorListMap),u=n.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&u.indexOf(c.id)===-1&&c.dispose()});let p=n;for(;l[0];){const c=p;p=await t.functionMap[s].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);const f=p.map(y=>y.id);c.forEach(y=>{!y.kept&&u.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()});const d=await t.functionMap[i].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(y=>{!y.kept&&u.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()})}return p}case"LoopCond":{const s=r("pred",a,e,t);return[ve(s)]}case"Switch":{const s=r("pred",a,e,t);let i=r("data",a,e,t);return i.kept||(i=ve(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=a.inputNames.find(i=>re(i,e,t)!==void 0);if(s){const i=re(s,e,t);return[ve(i)]}return}case"Enter":{const s=r("frameName",a,e,t),i=r("tensor",a,e,t);return t.enterFrame(s),[ve(i)]}case"Exit":{const s=r("tensor",a,e,t);return t.exitFrame(),[ve(s)]}case"NextIteration":{const s=r("tensor",a,e,t);return t.nextIteration(),[ve(s)]}case"TensorArrayV3":{const s=r("size",a,e,t),i=r("dtype",a,e,t),n=r("elementShape",a,e,t),o=r("dynamicSize",a,e,t),u=r("clearAfterRead",a,e,t),l=r("identicalElementShapes",a,e,t),p=r("name",a,e,t),c=new so(p,i,s,n,l,o,u);return t.addTensorArray(c),[c.idTensor,Te(1)]}case"TensorArrayWriteV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.write(i,n),[o.idTensor]}case"TensorArrayReadV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("dtype",a,e,t);return[t.getTensorArray(s.id).gather(i,n)]}case"TensorArrayScatterV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.scatter(i,n),[o.idTensor]}case"TensorArrayConcatV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id),n=r("dtype",a,e,t);return[i.concat(n)]}case"TensorArraySplitV3":{const s=r("tensorArrayId",a,e,t),i=r("tensor",a,e,t),n=r("lengths",a,e,t),o=t.getTensorArray(s.id);return o.split(n,i),[o.idTensor]}case"TensorArraySizeV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return[Te(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorList(s.id);return o.setItem(i,n),[o.idTensor]}case"TensorListGetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(i,n,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=r("indices",a,e,t),i=r("tensor",a,e,t),n=r("elementShape",a,e,t),o=r("numElements",a,e,t),u=io(i,s,n,o);return t.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=r("elementShape",a,e,t),i=r("elementDType",a,e,t);let n;a.op==="TensorListReserve"?n="numElements":n="maxNumElements";const o=r(n,a,e,t),u=no(s,i,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=r("tensorListId",a,e,t),i=r("indices",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).gather(i,o,n)]}case"TensorListStack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=r("numElements",a,e,t);return[t.getTensorList(s.id).stack(i,n,o)]}case"TensorListFromTensor":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=ro(s,i,n);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const s=r("tensorListId",a,e,t),i=t.getTensorList(s.id),n=r("dtype",a,e,t),o=r("elementShape",a,e,t);return[i.concat(n,o)]}case"TensorListPushBack":{const s=r("tensorListId",a,e,t),i=r("tensor",a,e,t),n=t.getTensorList(s.id);return n.pushBack(i),[n.idTensor]}case"TensorListPopBack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(i,n)]}case"TensorListSplit":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("lengths",a,e,t),o=oo(s,n,i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(a,e,t){const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=s==="fusedbatchnorm",l=r("numArgs",a,e,t);if(n){if(o&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const p=r("strides",a,e,t),c=Re(a,e,t),f=r("dataFormat",a,e,t).toUpperCase(),d=r("dilations",a,e,t),[y,b]=r("args",a,e,t),N=r("leakyreluAlpha",a,e,t);return{stride:p,pad:c,dataFormat:f,dilations:d,biasArg:y,preluArg:b,activationFunc:i,leakyreluAlpha:N}}const lo=(a,e,t)=>{switch(a.op){case"Conv1D":{const s=r("stride",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilation",a,e,t);return[xr(r("x",a,e,t),r("filter",a,e,t),s,i,n,o)]}case"Conv2D":{const s=r("strides",a,e,t),i=Re(a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[Cr(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,n,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:c}=Gt(a,e,t);return[zr({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:c}=Gt(a,e,t);return[yi({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=r("outputShape",a,e,t),i=r("strides",a,e,t),n=Re(a,e,t);return[Pr(r("x",a,e,t),r("filter",a,e,t),s,[i[1],i[2]],n)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=r("strides",a,e,t),i=Re(a,e,t),n=r("dilations",a,e,t),o=r("dataFormat",a,e,t).toUpperCase();return[ra(r("input",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,o,[n[1],n[2]])]}case"Conv3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[Dr(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2],s[3]],i,n,[o[1],o[2],o[3]])]}case"AvgPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[$r(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Ar(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t),o=r("includeBatchInIndex",a,e,t),{result:u,indexes:l}=ai(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i,o);return[u,l]}case"AvgPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Er(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Ir(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dilations",a,e,t),o=s[1],u=s[2],l=n[1],p=n[2];return[Or(r("x",a,e,t),r("filter",a,e,t),[o,u],i,[l,p],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const po=(a,e,t)=>{switch(a.op){case"Fill":{const s=r("shape",a,e,t),i=r("dtype",a,e,t),n=r("value",a,e,t);return[Wr(s,n,i)]}case"LinSpace":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("num",a,e,t);return[ei(s,i,n)]}case"Multinomial":{const s=r("logits",a,e,t),i=r("numSamples",a,e,t),n=r("seed",a,e,t);return[ri(s,i,n)]}case"OneHot":{const s=r("indices",a,e,t),i=r("depth",a,e,t),n=r("onValue",a,e,t),o=r("offValue",a,e,t);return[Hr(s,i,n,o)]}case"Ones":return[Br(r("shape",a,e,t),r("dtype",a,e,t))];case"OnesLike":return[Rr(r("x",a,e,t))];case"RandomUniform":return[jr(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("dtype",a,e,t))];case"Range":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("step",a,e,t);return[Fr(s,i,n,r("dtype",a,e,t))]}case"TruncatedNormal":{const s=r("shape",a,e,t),i=r("mean",a,e,t),n=r("stdDev",a,e,t),o=r("seed",a,e,t);return[Lr(s,i,n,r("dtype",a,e,t),o)]}case"Zeros":return[oa(r("shape",a,e,t),r("dtype",a,e,t))];case"ZerosLike":return[Vr(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(a,e,t){const s=r("boxes",a,e,t),i=r("scores",a,e,t),n=r("maxOutputSize",a,e,t),o=r("iouThreshold",a,e,t),u=r("scoreThreshold",a,e,t),l=r("softNmsSigma",a,e,t);return{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}}const mo=async(a,e,t)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=Ze(a,e,t),p=await Oe.nonMaxSuppressionWithScoreAsync(s,i,n,o,u,l);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=Ze(a,e,t),l=r("padToMaxOutputSize",a,e,t),p=await Oe.nonMaxSuppressionPaddedAsync(s,i,n,o,u,l);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=Ze(a,e,t);return[await Oe.nonMaxSuppressionAsync(s,i,n,o,u)]}case"Where":{const s=Ve(r("condition",a,e,t),"bool"),i=[await ui(s)];return s.dispose(),i}case"ListDiff":return ii(r("x",a,e,t),r("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co=(a,e,t)=>{switch(a.op){case"TopKV2":{const s=r("x",a,e,t),i=r("k",a,e,t),n=r("sorted",a,e,t),o=qr(s,i,n);return[o.values,o.indices]}case"Unique":{const s=r("x",a,e,t),i=Pt(s);return[i.values,i.indices]}case"UniqueV2":{const s=r("x",a,e,t),i=r("axis",a,e,t),n=Pt(s,i);return[n.values,n.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=(a,e,t)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const s=r("default",a,e,t);return[re(a.name,e,t)||s];case"Placeholder":return[re(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=r("x",a,e,t);return[ve(p)]}case"IdentityN":return r("x",a,e,t).map(p=>ve(p));case"Snapshot":const i=r("x",a,e,t);return[ve(i)];case"Shape":return[zt(r("x",a,e,t).shape,"int32")];case"ShapeN":return r("x",a,e,t).map(p=>zt(p.shape));case"Size":return[Te(r("x",a,e,t).size,"int32")];case"Rank":return[Te(r("x",a,e,t).rank,"int32")];case"NoOp":return[Te(1)];case"Print":const n=r("x",a,e,t),o=r("data",a,e,t),u=r("message",a,e,t),l=r("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,l));return[n];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ho{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Te(0),this.tensorMap=new Map,we(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Te(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),W(()=>{const i=Fe(t),n=s.length,o=i.length;j(n===o,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${o} elements.`);for(let u=0;u<n;u++){const l=s[u],p=i[u];we(p),this.tensorMap.set(l,p)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return W(()=>{const i=[];for(let n=0;n<s.length;n++){const o=s[n],u=this.findWithDefault(o,t);i.push(u)}return Le(i)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const i=r("keyDType",a,e,t),n=r("valueDType",a,e,t),o=new ho(i,n);return s.addHashTable(a.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("values",a,e,t);return[await s.getHashTableById(i.id).import(n,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("defaultValue",a,e,t);return[await s.getHashTableById(i.id).find(n,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=r("tableHandle",a,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go=(a,e,t)=>{switch(a.op){case"ResizeBilinear":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Oe.resizeBilinear(s,[i[0],i[1]],n,o)]}case"ResizeNearestNeighbor":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Oe.resizeNearestNeighbor(s,[i[0],i[1]],n,o)]}case"CropAndResize":{const s=r("image",a,e,t),i=r("boxes",a,e,t),n=r("boxInd",a,e,t),o=r("cropSize",a,e,t),u=r("method",a,e,t),l=r("extrapolationValue",a,e,t);return[Oe.cropAndResize(s,i,n,o,u,l)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo=(a,e,t)=>{switch(a.op){case"Equal":return[en(r("a",a,e,t),r("b",a,e,t))];case"NotEqual":return[Mr(r("a",a,e,t),r("b",a,e,t))];case"Greater":return[Qr(r("a",a,e,t),r("b",a,e,t))];case"GreaterEqual":return[Xr(r("a",a,e,t),r("b",a,e,t))];case"Less":return[Zr(r("a",a,e,t),r("b",a,e,t))];case"LessEqual":return[Yr(r("a",a,e,t),r("b",a,e,t))];case"LogicalAnd":return[Jr(r("a",a,e,t),r("b",a,e,t))];case"LogicalNot":return[Kr(r("a",a,e,t))];case"LogicalOr":return[Ur(r("a",a,e,t),r("b",a,e,t))];case"Select":case"SelectV2":return[Gr(r("condition",a,e,t),r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No=(a,e,t)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[sn(r("a",a,e,t),r("b",a,e,t),r("transposeA",a,e,t),r("transposeB",a,e,t))];case"Transpose":return[an(r("x",a,e,t),r("perm",a,e,t))];case"_FusedMatMul":const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=r("numArgs",a,e,t),l=r("leakyreluAlpha",a,e,t);if(n){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,c]=r("args",a,e,t);return[tn({a:r("a",a,e,t),b:r("b",a,e,t),transposeA:r("transposeA",a,e,t),transposeB:r("transposeB",a,e,t),bias:p,activation:i,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=(a,e,t)=>{switch(a.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Ct(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"FusedBatchNormV3":return[Ct(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"LRN":return[on(r("x",a,e,t),r("radius",a,e,t),r("bias",a,e,t),r("alpha",a,e,t),r("beta",a,e,t))];case"Softmax":return[nn(r("x",a,e,t))];case"LogSoftmax":return[rn(r("x",a,e,t))];case"SparseToDense":return[ma(r("sparseIndices",a,e,t),r("outputShape",a,e,t),r("sparseValues",a,e,t),r("defaultValue",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const To=(a,e,t)=>{switch(a.op){case"Max":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[yn(r("x",a,e,t),o,u)]}case"Mean":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[hn(r("x",a,e,t),o,u)]}case"Min":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[fn(r("x",a,e,t),o,u)]}case"Sum":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[dn(r("x",a,e,t),o,u)]}case"All":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[cn(r("x",a,e,t),o,u)]}case"Any":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[mn(r("x",a,e,t),o,u)]}case"ArgMax":{const o=r("axis",a,e,t);return[pn(r("x",a,e,t),o)]}case"ArgMin":{const o=r("axis",a,e,t);return[ln(r("x",a,e,t),o)]}case"Prod":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[ia(r("x",a,e,t),o,u)]}case"Cumsum":{const o=r("axis",a,e,t),u=r("exclusive",a,e,t),l=r("reverse",a,e,t);return[un(r("x",a,e,t),o,u,l)]}case"Bincount":const s=r("x",a,e,t),i=r("weights",a,e,t),n=r("size",a,e,t);return[Xn(s,i,n)];case"DenseBincount":{const o=r("x",a,e,t),u=r("weights",a,e,t),l=r("size",a,e,t),p=r("binaryOutput",a,e,t);return[Mn(o,u,l,p)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So=(a,e,t)=>{switch(a.op){case"ConcatV2":case"Concat":{const s=r("n",a,e,t),i=r("axis",a,e,t);let n=r("tensors",a,e,t);return n=n.slice(0,s),[ft(n,i)]}case"Gather":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[Vt(s,Ve(i,"int32"),0)]}case"GatherV2":{const s=r("axis",a,e,t),i=r("batchDims",a,e,t),n=r("x",a,e,t),o=r("indices",a,e,t);return[Vt(n,Ve(o,"int32"),s,i)]}case"Reverse":{const s=r("dims",a,e,t),i=[];for(let o=0;o<s.length;o++)s[o]&&i.push(o);const n=r("x",a,e,t);return[xt(n,i)]}case"ReverseV2":{const s=r("axis",a,e,t),i=r("x",a,e,t);return[xt(i,s)]}case"Slice":{const s=r("begin",a,e,t),i=r("size",a,e,t);return[ht(r("x",a,e,t),s,i)]}case"StridedSlice":{const s=r("begin",a,e,t),i=r("end",a,e,t),n=r("strides",a,e,t),o=r("beginMask",a,e,t),u=r("endMask",a,e,t),l=r("ellipsisMask",a,e,t),p=r("newAxisMask",a,e,t),c=r("shrinkAxisMask",a,e,t),f=r("x",a,e,t);return[Nn(f,s,i,n,o,u,l,p,c)]}case"Pack":return W(()=>{const s=r("axis",a,e,t),i=r("tensors",a,e,t),n=i[0].shape,o=Qe(i[0]).shape,u=i.map(l=>{const p=Xe(l.shape,n);if(!p&&!Xe(Qe(l).shape,o))throw new Error("the input tensors shape does not match");return p?l:ae(l,n)});return[Le(u,s)]});case"Unpack":{const s=r("axis",a,e,t),i=r("tensor",a,e,t);return Fe(i,s)}case"Tile":{const s=r("reps",a,e,t);return[bn(r("x",a,e,t),s)]}case"Split":case"SplitV":{const s=r("axis",a,e,t),i=r("numOrSizeSplits",a,e,t),n=r("x",a,e,t);return gn(n,i,s)}case"ScatterNd":{const s=r("indices",a,e,t),i=r("values",a,e,t),n=r("shape",a,e,t);return[pi(s,i,n)]}case"GatherNd":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[fi(s,i)]}case"SparseToDense":{const s=r("sparseIndices",a,e,t),i=r("outputShape",a,e,t),n=r("sparseValues",a,e,t),o=r("defaultValue",a,e,t);return[ma(s,n,i,n.dtype===o.dtype?o:Ve(o,n.dtype))]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo=(a,e,t)=>{switch(a.op){case"FFT":return[wn(r("x",a,e,t))];case"IFFT":return[Sn(r("x",a,e,t))];case"RFFT":return[Tn(r("x",a,e,t))];case"IRFFT":return[vn(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _o=(a,e,t)=>{switch(a.op){case"Cast":return[Ve(r("x",a,e,t),r("dtype",a,e,t))];case"ExpandDims":{const s=r("axis",a,e,t);return[$n(r("x",a,e,t),s)]}case"Squeeze":{const s=r("axis",a,e,t);return[Qe(r("x",a,e,t),s)]}case"Reshape":return[ae(r("x",a,e,t),r("shape",a,e,t))];case"MirrorPad":return[An(r("x",a,e,t),r("padding",a,e,t),r("mode",a,e,t))];case"PadV2":case"Pad":return[En(r("x",a,e,t),r("padding",a,e,t),r("constantValue",a,e,t))];case"SpaceToBatchND":{const s=r("blockShape",a,e,t),i=r("paddings",a,e,t);return[In(r("x",a,e,t),s,i)]}case"BatchToSpaceND":{const s=r("blockShape",a,e,t),i=r("crops",a,e,t);return[On(r("x",a,e,t),s,i)]}case"DepthToSpace":{const s=r("blockSize",a,e,t),i=r("dataFormat",a,e,t).toUpperCase();return[kn(r("x",a,e,t),s,i)]}case"BroadcastTo":return[_n(r("x",a,e,t),r("shape",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ut(a,e,t,s){const i=((n,o,u)=>{switch(n.category){case"arithmetic":return W(()=>to(n,o,u));case"basic_math":return W(()=>ao(n,o,u));case"control":return uo(n,o,u);case"convolution":return W(()=>lo(n,o,u));case"creation":return W(()=>po(n,o,u));case"dynamic":return mo(n,o,u);case"evaluation":return W(()=>co(n,o,u));case"image":return W(()=>go(n,o,u));case"graph":return W(()=>fo(n,o,u));case"logical":return W(()=>bo(n,o,u));case"matrices":return W(()=>No(n,o,u));case"normalization":return W(()=>vo(n,o,u));case"reduction":return W(()=>To(n,o,u));case"slice_join":return W(()=>So(n,o,u));case"spectral":return W(()=>wo(n,o,u));case"transformation":return W(()=>_o(n,o,u));case"hash_table":return yo(n,o,u,s);case"custom":const l=ca(n.op);if(l&&l.customExecutor)return l.customExecutor(new eo(n,o,u));throw TypeError(`Custom op ${n.op} is not registered.`);default:throw TypeError(`Unknown op '${n.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return Me(i)?i.then(n=>[].concat(n)):[].concat(i)}class Kt{constructor(e={},t={},s={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jt(a,e,t,s){const i=new Set,n=[];let o=null,u=null;const l=new Set,p=Object.keys(a).map(d=>ie(d)[0]);let c=[];s!=null&&(c=s.map(d=>ie(d.name)[0]));const f=[...e];for(;f.length>0;){const d=f.pop();if((ha(d)||Ao(d)||$o(d))&&o==null&&(o=d,u=o.children.map(y=>y.name).filter(y=>i.has(y))),i.add(d.name),t[d.name]==null&&p.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){n.push(d.name);continue}d.inputs.forEach(y=>{l.has(y.name)||(l.add(y.name),f.push(y))})}}return{inputs:a,outputs:e,usedNodes:i,missingInputs:n,dynamicNode:o,syncInputs:u}}function ko(a,e,t){const{usedNodes:s,inputs:i}=t,n=[],o=Object.keys(i).map(c=>ie(c)[0]).map(c=>a.nodes[c]),u=a.initNodes;o.forEach(c=>{s.has(c.name)&&n.push(c)}),a.weights.forEach(c=>{s.has(c.name)&&n.push(c)}),u!=null&&u.forEach(c=>{s.has(c.name)&&n.push(c)});const l=new Set,p=[];for(;n.length>0;){const c=n.pop();l.add(c.name),e[c.name]||p.push(c),c.children.forEach(f=>{!l.has(f.name)&&s.has(f.name)&&f.inputs.every(d=>l.has(d.name))&&n.push(f)})}return p}const Oo=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Io=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Eo=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function ha(a){return Oo.indexOf(a.op)>=0}function Ao(a){return Io.indexOf(a.op)>=0}function $o(a){return Eo.indexOf(a.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class We{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new We(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(n=>n.name).sort(),i=t.map(n=>n.name).sort();return s.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const s=Jt(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:n,syncInputs:o}=s;if(n!=null)throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const u=t.map(p=>p.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return ko(this.graph,this.weightMap,s)}execute(e,t){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(f=>this.graph.nodes[ie(f)[0]]),n=t.map(f=>ie(f)[0]);let o=n.map(f=>this.graph.nodes[f]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(i,o);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,o),this.compiledMap.set(u,l));const p={},c={};return W(()=>{const f=new Kt(this.weightMap,p,c,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[v,B]=ie(N),J=[];J[B]=e[N],d[v]=J});const y=this.getFrozenTensorIds(d),b={};for(let N=0;N<l.length;N++){const v=l[N];if(!d[v.name]){const B=Ut(v,d,f,this._resourceManager);if(Me(B))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);d[v.name]=B,this.checkTensorForDisposal(v.name,v,d,f,y,n,b)}}return this.parent==null&&f.dispose(y),t.map(N=>re(N,d,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,n,o,u){t.category==="control"||o.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(u[l.id]=(u[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const p=bi(l.name,s,i);p!=null&&p.forEach(c=>{if(c&&!n.has(c.id)){const f=u[c.id];f===1?(c.dispose(),delete u[c.id]):f!=null&&u[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,s=!1,i={},n={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const o=new Kt(this.weightMap,i,n,this.functionExecutorMap),u=await this.executeWithControlFlow(e,o,t,s),l=t.map(d=>re(d,u,o)),p=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),f=new Set([...p,...c,...this.weightIds]);return Object.keys(u).forEach(d=>{u[d].forEach(b=>{b&&!b.isDisposed&&!f.has(b.id)&&b.dispose()})}),this.parent==null&&o.dispose(f),l}async executeFunctionAsync(e,t,s){const i=e.reduce((n,o,u)=>(n[this.inputs[u].name]=o,n),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const n=Object.keys(e),o=n.map(C=>this.graph.nodes[ie(C)[0]]),u=s.map(C=>ie(C)[0]);let l=u.map(C=>this.graph.nodes[C]);l.length===0&&(l=this._outputs);const{usedNodes:p,missingInputs:c,dynamicNode:f,syncInputs:d}=Jt(e,l,this.weightMap,this._initNodes),y=[...o,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[fe,ne]=ie(C),F=[];F[ne]=e[C],b[fe]=F});const N={},v=this.getFrozenTensorIds(b),B={};for(;y.length>0;){const C=this.processStack(o,y,t,b,B,v,u,N,p);await Promise.all(C)}f==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const J=l.filter(C=>!ha(C)&&!re(C.name,b,t)).map(C=>C.name);if(J.length>0){let C="";throw f!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${J}] from the provided inputs [${n}]. Consider providing the following inputs: [${c}]. ${C}`)}return b}processStack(e,t,s,i,n,o,u,l,p){const c=[];for(;t.length>0;){const f=t.pop();s.currentContext=f.contexts;let d="";if(f.node.op==="Enter"&&r("isConstant",f.node,i,s)&&([d]=Ne(f.node.name,s)),i[f.node.name]==null){const y=Ut(f.node,i,s,this._resourceManager);d||([d]=Ne(f.node.name,s));const b=s.currentContext;Me(y)?c.push(y.then(N=>(i[d]=N,s.currentContext=b,this.checkTensorForDisposal(d,f.node,i,s,o,u,l),this.processChildNodes(f.node,t,s,i,n,p),N))):(i[d]=y,this.checkTensorForDisposal(d,f.node,i,s,o,u,l),this.processChildNodes(f.node,t,s,i,n,p))}else this.processChildNodes(f.node,t,s,i,n,p)}return c}processChildNodes(e,t,s,i,n,o){e.children.forEach(u=>{const[l]=Ne(u.name,s);n[l]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(p=>!!re(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})):u.inputNames.every(p=>!!re(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=ie(t),n=this.graph.nodes[i];if(n.attrParams.shape&&n.attrParams.shape.value){const o=n.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((l,p)=>o[p]===-1||o[p]===l);j(u,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&j(s.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const t={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const i=this._signature.inputs[s];t[i.name]=e[s]}else t[s]=e[s];return t}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=ie(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[s]=ie(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Do{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po="?tfjs-format=file",zo="model.json";class Co{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new Do}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Bt(e,this.loadOptions);else{const t=Dn(e,this.loadOptions);if(t.length===0)t.push(Bt(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=Pn(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new We(Ht.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const n=Ht.Instance.transformGraph(e.modelInitializer);this.initializer=new We(n),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=zn(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ua)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,s,i)=>(t[s]=e[i],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function xo(a,e={}){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&a.load==null&&(a.endsWith("/")||(a=a+"/"),a=`${a}${zo}${Po}`);const t=new Co(a,e);return await t.load(),t}/**
 * @license
 * Copyright 2019 Victor Dibia.
 * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.
 * Licensed under the MIT License (the "License");
 * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
 * =============================================================================
 */const Vo="https://cdn.jsdelivr.net/npm/handtrackjs@latest/models/webmodel/",Lo={1:"open",2:"closed",3:"pinch",4:"point",5:"face",6:"pointtip",7:"pinchtip"},Fo={flipHorizontal:!1,outputStride:16,imageScaleFactor:1,maxNumBoxes:20,iouThreshold:.2,scoreThreshold:.6,modelType:"ssd320fpnlite",modelSize:"small",bboxLineWidth:"2",fontSize:17,basePath:Vo,labelMap:Lo,renderThresholds:null},jo={large:"base",medium:"fp16",small:"int8"},Yt={open:"#374151",closed:"#B91C1C",pinch:"#F59E0B",point:"#10B981",face:"#3B82F6",pointtip:"#6366F1",pinchtip:"#EC4899"},Zt={ssd320fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],ssd640fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],centernet512fpn:["Identity_4:0","Identity:0","Identity_2:0"]};async function Ro(a){let e=Object.assign({},Fo,a);const t=new Wo(e);return await t.load(),t}function Bo(a){return new Promise(function(e,t){a||e({status:!1,msg:"please provide a valid video element"}),a.width=a.width||640,a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height="20px",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(s=>{window.localStream=s,a.srcObject=s,a.onloadedmetadata=()=>{a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height=parseInt(a.style.width)*(a.videoHeight/a.videoWidth).toFixed(2)+"px",a.play(),e({status:!0,msg:"webcam successfully initiated."})}}).catch(function(s){e({status:!1,msg:s})})})}async function Ho(){if(window.localStream)window.localStream.getTracks().forEach(a=>(a.stop(),!0));else return!1}class Wo{constructor(e){this.modelPath=e.basePath+e.modelType+"/"+(jo[e.modelSize]||"base")+"/model.json ",this.modelParams=e}async load(){this.fps=0,this.model=await xo(this.modelPath);const e=oa([1,300,300,3],"int32"),t=await this.model.executeAsync(e,Zt[this.modelParams.modelType]);t.map(async s=>await s.data()),t.map(async s=>s.dispose()),Ye(e)}async detect(e){let t=Date.now();const[s,i]=qo(e),n=Xt(this.modelParams.imageScaleFactor,s,this.modelParams.outputStride),o=Xt(this.modelParams.imageScaleFactor,i,this.modelParams.outputStride),u=W(()=>{const p=Kn(e);return this.modelParams.flipHorizontal?p.reverse(1).resizeBilinear([n,o]).expandDims(0).toInt():p.resizeBilinear([n,o]).expandDims(0).toInt()}),l=this;return this.model.executeAsync(u,Zt[this.modelParams.modelType]).then(function(p){u.dispose();let c=[];if(l.modelParams.modelType==="centernet512fpn"){const d=p[0].dataSync(),y=p[1].arraySync(),b=p[2].dataSync();Ye(p),c=l.buildDetectObjectsCenternet(i,s,y[0],d,b),console.log(c)}else{const d=p[0].dataSync(),y=p[1].dataSync();Ye(p);const[b,N]=Go(d,p[0].shape[1],p[0].shape[2]),v=Cn();Lt("cpu");const B=W(()=>{const C=xn(y,[p[1].shape[1],p[1].shape[3]]);return Oe.nonMaxSuppression(C,b,l.modelParams.maxNumBoxes,l.modelParams.iouThreshold,l.modelParams.scoreThreshold)}),J=B.dataSync();B.dispose(),Lt(v),c=l.buildDetectedObjects(i,s,y,b,J,N)}let f=Date.now();return l.fps=Math.round(1e3/(f-t)),c})}buildDetectedObjects(e,t,s,i,n,o){const u=n.length,l=[];for(let p=0;p<u;p++){const c=[];for(let v=0;v<4;v++)c[v]=s[n[p]*4+v];const f=c[0]*t,d=c[1]*e,y=c[2]*t,b=c[3]*e;c[0]=d,c[1]=f,c[2]=b-d,c[3]=y-f;const N=Math.round(o[n[p]])+1;l.push({bbox:c,class:N,label:this.modelParams.labelMap[N],score:i[n[p]].toFixed(2)})}return l}buildDetectObjectsCenternet(e,t,s,i,n){const o=[];for(let u=0;u<i.length;u++){const l=s[u],p=l[0]*t,c=l[1]*e,f=l[2]*t,d=l[3]*e;l[0]=c,l[1]=p,l[2]=d-c,l[3]=f-p;const y=Math.round(n[u])+1;o.push({bbox:l,class:y,label:this.modelParams.labelMap[y],score:i[u].toFixed(2)})}return o.slice(0,10)}getFPS(){return this.fps}setModelParameters(e){this.modelParams=Object.assign({},this.modelParams,e)}getModelParameters(){return this.modelParams}roundRect(e,t,s,i,n,o,u,l){if(typeof l>"u"&&(l=!0),typeof o>"u"&&(o=5),typeof o=="number")o={tl:o,tr:o,br:o,bl:o};else{var p={tl:0,tr:0,br:0,bl:0};for(var c in p)o[c]=o[c]||p[c]}e.beginPath(),e.moveTo(t+o.tl,s),e.lineTo(t+i-o.tr,s),e.quadraticCurveTo(t+i,s,t+i,s+o.tr),e.lineTo(t+i,s+n-o.br),e.quadraticCurveTo(t+i,s+n,t+i-o.br,s+n),e.lineTo(t+o.bl,s+n),e.quadraticCurveTo(t,s+n,t,s+n-o.bl),e.lineTo(t,s+o.tl),e.quadraticCurveTo(t,s,t+o.tl,s),e.closePath(),u&&e.fill(),l&&e.stroke()}renderPredictions(e,t,s,i){s.clearRect(0,0,t.width,t.height),t.width=i.width,t.height=i.height,t.style.height=parseInt(t.style.width)*(i.height/i.width).toFixed(2)+"px",s.save(),this.modelParams.flipHorizontal&&(s.scale(-1,1),s.translate(-i.width,0)),s.drawImage(i,0,0,i.width,i.height),s.restore(),s.font="bold "+this.modelParams.fontSize+"px Arial";const n=this.modelParams.renderThresholds;for(let o=0;o<e.length;o++){const u=e[o];(!n||u.score>n[u.label])&&(s.beginPath(),s.fillStyle="rgba(255, 255, 255, 0.6)",s.fillRect(u.bbox[0]+1,u.bbox[1]+1,u.bbox[2]-1,this.modelParams.fontSize*1.5),s.lineWidth=this.modelParams.bboxLineWidth,this.roundRect(s,u.bbox[0],u.bbox[1],u.bbox[2],u.bbox[3],5,!1,!0),s.strokeStyle=Yt[u.label],s.fillStyle=Yt[u.label],s.stroke(),s.beginPath(),s.arc(u.bbox[0]+u.bbox[2]/2,u.bbox[1]+u.bbox[3]/2,2,0,2*Math.PI),s.fill(),s.stroke(),s.fillText(u.score+" | "+u.label,u.bbox[0]+5,u.bbox[1]+this.modelParams.fontSize*1.1))}s.fillStyle="rgba(255, 255, 255, 0.6)",this.roundRect(s,10,10,this.modelParams.fontSize*4.6,this.modelParams.fontSize+8,5,!0,!1),s.strokeStyle="#374151",s.fillStyle="#374151",s.font="bold "+this.modelParams.fontSize+"px Arial",s.fillText("FPS: "+this.fps,18,this.modelParams.fontSize+12)}dispose(){this.model&&this.model.dispose()}}function Xt(a,e,t){const s=e*a-1;return s-s%t+1}function qo(a){return a instanceof ua?[a.shape[0],a.shape[1]]:[a.height,a.width]}function Go(a,e,t){const s=[],i=[];for(let n=0;n<e;n++){let o=Number.MIN_VALUE,u=-1;for(let l=0;l<t;l++)a[n*t+l]>o&&(o=a[n*t+l],u=l);s[n]=o,i[n]=u}return[s,i]}const Uo={class:"mt-2"},Ko={class:"mb-1 mt-2"},Jo={class:"text-medium-emphasis"},Yo={class:"mt-2"},Zo={class:"text-h4 text-medium-emphasis mt-4"},Xo={key:0,style:{"font-style":"italic","font-size":"1.2em"},class:"mt-3"},Qo=["id"],Mo={key:0},eu=["innerHTML"],tu={key:1,class:"mt-6"},au={key:0,class:"mb-4"},su={key:1},ru={style:{"font-size":"0.9em"}},nu={class:"mt-4"},iu={class:"text-center",style:{"margin-top":"40px"}},ou={key:0},uu={class:"text-center mt-2",id:"ratingPart"},lu={class:"text-medium-emphasis mt-6"},pu={key:2,class:"custom-bottom-sheet no-print"},mu={class:"sheet-content",style:{"background-color":"rgb(226, 226, 226)"}},cu={key:0,class:"mb-2"},du={class:"my-1"},fu={key:1,class:"mb-2"},hu={class:"my-1"},yu={key:2,class:"sheet-ingredients"},gu={key:0},bu={key:1},Nu={key:0,class:"mb-2"},vu={style:{"font-size":"1.7em","border-radius":"6px","background-color":"#ffffff",color:"#3d3d3d"},class:"px-2"},Tu={key:0},Su={key:1},wu={style:{"background-color":"rgb(203, 203, 204)",display:"flex"}},_u={class:"ml-2",style:{width:"100px","flex-shrink":"0"}},ku={class:"mx-2",style:{flex:"1"}},Ou={class:"mr-2",style:{width:"100px","flex-shrink":"0"}},Qt="*",Iu={__name:"MealMaker",setup(a){It.extend(Ba);const e=ea(),t=ta(),{authInfo:s,githubMode:i,lanAddress:n}=Ha(t),o=aa(),l=mt().query.id,p=z(null),c=z(null),f=z(2),d=z([]),y=z(null),b=z(!1),N=z(!1),v=z(null),B=z(null),J=z([]),C=z(!0),fe=z(!0),ne=z(!0),F=z([]),pe=z(!1),q=z(null),Y=z(null),X=z(!1),Ie=z([]),M=z(-1),Ce=z([]),Ee=z(!1),Ae=z(!1),qe=z(60);ct(async()=>{p.value=null,c.value=null;let h=await t.getAuthInfo();if(await je(),await ue(!0),p.value.planned&&!p.value.cooked&&!i.value){let k=h.calendarPlan??{};const w=new Date,E=w.getFullYear(),A=String(w.getMonth()+1).padStart(2,"0"),O=String(w.getDate()).padStart(2,"0");k[`${E}-${A}-${O}`]&&(k[`${E}-${A}-${O}`].type==="RECIPE"&&k[`${E}-${A}-${O}`].recipeId&&k[`${E}-${A}-${O}`].recipeId!==p.value.id||k[`${E}-${A}-${O}`].type==="SCHEDULED"||k[`${E}-${A}-${O}`].type==="OTHER")?Ee.value=!0:(Ae.value=!0,setTimeout(async()=>{for(let P=0;P<60&&Ae.value!==!1;P++){if(qe.value--,qe.value===0){Ae.value=!1,await Ge();break}await new Promise(G=>setTimeout(G,1e3))}},100))}const m=localStorage.getItem("timers-"+l);if(m)try{const k=JSON.parse(m);k.forEach(w=>{w.isPaused=!0}),d.value=k.map(w=>({...w,timeoutId:null}))}catch(k){console.error("Timer konnte nicht geladen werden:",k)}}),Wa(()=>{d.value.forEach(h=>clearTimeout(h.timeoutId)),clearTimeout(y.value)}),qa(d,h=>{const m=h.map(({timeoutId:k,...w})=>w);localStorage.setItem("timers-"+l,JSON.stringify(m))},{deep:!0}),window.addEventListener("message",h=>{var k;const m=h.data;if(!(!m||typeof m!="object")&&(m.type==="speech-commands:ready"&&console.log(`iFrame bereit (${((k=m.vocab)==null?void 0:k.length)||0} WÃ¶rter)`),m.type==="speech-commands:result")){const w=m.scores.find(O=>O.label==="go"),E=m.scores.find(O=>O.label==="one"),A=m.scores.find(O=>O.label==="eight");w&&w.score>=.7&&(X.value=!0,q.value="HEARING",Y.value&&clearTimeout(Y.value),Y.value=setTimeout(()=>{X.value=!1,q.value="LISTENING"},2e3)),(E&&E.score>=.8||A&&A.score>=.8)&&X.value&&(X.value=!1,q.value="CLOSED",Ft.reduceExecutions("speech-commands",()=>{M.value++,ue(),Y.value=setTimeout(()=>{q.value="LISTENING"},1e3)},1e3))}});async function ya(){await ge.planRecipe(s.value.userId,l),await je()}async function Ge(){const h={cooked:!0};await ge.updateRecipe(s.value.userId,l,h),ge.uploadRecipeToGithub(s.value.userId,null);let m=s.value.calendarPlan;m||(m={});const k=new Date,w=k.getFullYear(),E=String(k.getMonth()+1).padStart(2,"0"),A=String(k.getDate()).padStart(2,"0");m[`${w}-${E}-${A}`]={type:"RECIPE",recipeId:l,recipeTitle:p.value.title,cooked:!0},await Za.saveCalendarPlan(s.value.userId,m),Ee.value=!1,Ae.value=!1}const ga=Je(()=>!F||F.value.length===0?0:F.value.filter(h=>!h.ingredient&&h.duration).reduce((h,m)=>h+m.duration,0)),bt=Je(()=>!F||F.value.length===0?[]:F.value.filter(h=>!!h.ingredient)),ba=Je(()=>!F||F.value.length===0?[]:F.value.filter(h=>!h.ingredient));function Na(){const h=[];p.value.ingredients.forEach(m=>{if(m.preparationRequired){let k=m.preparationLongText;const w=c.value.find(E=>m.name===E.name);if(w){let E="";E=w.amount?w.amount+(w.unit?" "+w.unit:"")+" ":"",k?k=k.replace(m.basicName,E+" "+m.basicName):k=E+" "+m.basicName+" vorbereiten."}h.push({name:k,ingredient:!0})}}),p.value.sections.forEach(m=>{m.ingredientsPreparations&&m.ingredientsPreparations.length>0&&m.ingredientsPreparations.forEach(k=>{let w=[],E=k.instruction;for(let A=0;A<m.usedIngredients.length;A++){let O=m.usedIngredients[A];const P=c.value.find(Z=>Z.name===O.ingredientNameList);let G="";P&&!w.includes(P.name)&&(G=P.amount?P.amount+(P.unit?" "+P.unit:"")+" ":"",w.push(P.name),E=E.replace(O.ingredientNameText,G+" "+O.ingredientNameText))}h.push({name:E,originalName:k.instruction,sectionIndex:m.index-1,duration:k.duration})})}),F.value=h}function va(){M.value=-1,C.value=!0,ue()}function Ta(h){return i.value?"https://mmhhhh.de/data/home/recipes/"+h.id+"/image.jpg":n.value+"api/"+s.value.userId+"/recipes/"+h.id+"/image"}function Nt(){window.close(),setTimeout(()=>{document.title="Cookio - Rezeptmanager",o.push("/recipes")},500)}async function Sa(){const h={preparations:[]};await ge.updateRecipe(s.value.userId,l,h),await je(),await ue(!0)}function wa(h){_t(h),ue(!0)}async function _a(h){const m={rating:h};await ge.updateRecipe(s.value.userId,l,m),await ue()}async function vt(){if(!i.value){const h={preparations:F.value};await ge.updateRecipe(s.value.userId,l,h),await ue()}}function ka(h){h&&!h.target.closest(".stopwatch-button")&&(M.value>-1&&M.value--,ue())}function Tt(h){h&&!h.target.closest(".stopwatch-button")&&(M.value++,ue())}async function je(){p.value=await ge.getRecipe(s.value.userId,l),p.value.ingredients=(await ge.getRecipeIngredients(s.value.userId,l)).data,p.value.sections=(await ge.getRecipeSections(s.value.userId,l)).data,ue(!0)}async function ue(h=!1){let m=JSON.parse(JSON.stringify(p.value.sections));_t(),h&&(p.value.preparations&&p.value.preparations.length>0?F.value=p.value.preparations:Na()),Ie.value=[];let k=-1;if(d.value)for(let O=d.value.length-1;O>=0;O--)(d.value[O].remainingSeconds===0||!d.value[O].timerStarted)&&(d.value=d.value.filter(P=>P.id!==d.value[O].id||P.id===d.value[O].id&&d.value[O].timerStarted));const w=[];let E=null,A=0;for(let O=0;O<m.length;O++){let P=m[O],G=P.description,Z="",me=xa(G);if(A=k+me.length,me.forEach((x,$)=>{k++,Ie.value.push(x);const D=F.value.find(U=>U.checked&&O===U.sectionIndex&&U.originalName===x);if(M.value>A||M.value>=k)Z=Z+'<span style="color: #9a9a9a;">'+x+" </span>";else if(M.value+1===k){if(D)Z=Z+'<span style="color: #9a9a9a;">'+x+" </span>",M.value++;else if(e.smAndDown.value?Z=Z+'<span style="background-color: #bfe7d2; font-size: 1.4em; box-decoration-break: clone;-webkit-box-decoration-break: clone;" class="pa-2">'+x+" </span> ":Z=Z+'â–¶&nbsp;<span style="background-color: #bfe7d2; padding-top: 4px; padding-bottom: 4px">'+x+" </span> ",P.timer&&P.timer.length>0)for(let U=0;U<P.timer.length;U++)x.includes(P.timer[U].descriptionText)&&d.value.push({id:O+"-"+U,title:P.timer[U].title,remainingSeconds:P.timer[U].duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:P.timer[U].descriptionTextAfter})}else Z=Z+x+" "}),G=Z,M.value+1>A&&m.length>O+1&&(E=O+1),P.timer&&P.timer.length>0){let x="",$=G;for(let D=0;D<P.timer.length;D++){const he=P.timer[D].descriptionText,ee=$.indexOf(he);if(ee===-1)continue;x+=$.slice(0,ee);const Q=`<span class="pa-1 stopwatch-button" style="cursor: pointer; background-color: rgba(187,187,187,0.66); border: rgba(41,56,80,0.49) solid 3px; border-radius: 20px; color: #545454; font-size: 0.9em" data-id="${D}" data-sectionid="${O}"> â± ${he}</span>`;x+=Q,$=$.slice(ee+he.length)}x+=$,G=x}N.value||P.ingredientsPreparations.forEach(x=>{F.value.find(D=>D.checked&&O===D.sectionIndex&&D.originalName===x.instruction)&&(G=G.replace(x.instruction,'<span style="text-decoration-line: line-through;text-decoration-style: solid;text-decoration-thickness: 2px;text-underline-offset: 4px;">'+x.instruction+"</span>"))}),P.usedIngredients.forEach(x=>{const $=c.value.find(U=>U.name===x.ingredientNameList);let D="";$&&!w.includes($.name)&&(D=$.amount?$.amount+($.unit?" "+$.unit:"")+" ":"",w.push($.name)),G=G.replace(x.ingredientNameText,"<b>"+D+x.ingredientNameText+"</b>")}),P.description=G}M.value>A-1&&(C.value=!1),Ce.value=m,ne.value||setTimeout(()=>{document.getElementById("section-"+E).scrollIntoView({behavior:"smooth",block:"start"})},200),ne.value=!1,document.title=p.value.title+" - Cookio"}function Oa(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"start"},Qt),pe.value=!0,q.value="LISTENING"}function Ia(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"stop"},Qt),pe.value=!1,q.value=null}function St(h){v.value(h)}function wt(){N.value=!N.value,C.value=!N.value,fe.value=!N.value,ue()}function _t(h){h&&(f.value=h);let m=p.value.portions?p.value.portions:2;c.value=[],p.value.ingredients.forEach(k=>{c.value.push({name:k.name,unit:k.unit,amount:Math.ceil(k.amount/m*f.value)})})}function Ea(h){const m=h.target.closest(".stopwatch-button");if(m){const k=m.dataset.id,w=m.dataset.sectionid,E=parseInt(k,10),A=parseInt(w,10),O=p.value.sections[A].timer[E];d.value.push({id:A+"-"+E,title:O.title,remainingSeconds:O.duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:O.descriptionTextAfter})}}const Aa=h=>{const m=It.duration(h*1e3),k=String(m.minutes()).padStart(2,"0"),w=String(m.seconds()).padStart(2,"0");return`${k}:${w}`};function $a(h){d.value=d.value.filter(m=>m.id!==h)}const Ue=h=>{h.isPaused||h.remainingSeconds<=0||d.value.find(m=>m.id===h.id)&&(h.remainingSeconds--,h.remainingSeconds<=0&&(J.value.push(h),B.value(J.value).then(()=>{J.value=[],d.value=d.value.filter(m=>m.remainingSeconds>0)})),h.remainingSeconds>0?h.timeoutId=setTimeout(()=>Ue(h),1e3):h.timeoutId=null)},Da=h=>{clearTimeout(h.timeoutId),h.timerStarted=!0,h.isPaused=!1,h.timeoutId=setTimeout(()=>Ue(h),1e3)},Pa=h=>{h.isPaused=!h.isPaused,!h.isPaused&&h.remainingSeconds>0&&(h.timeoutId=setTimeout(()=>Ue(h),1e3))},za=h=>{h.remainingSeconds=h.remainingSeconds+60},Ca=h=>{const m=h.remainingSeconds-60;h.remainingSeconds=Math.max(m,0)};function xa(h,m=[]){const k=["ca.","etc.","ggf.","bspw.","bzw.","vgl.","Dr.","Prof.","Nr.","Stk.","Abs.","Art.","Sek.","Std.","Min.","z. B.","u. a.","i. d. R.","z. T.","sog."],w=D=>D.toLowerCase().replace(/[.\s]/g,""),E=new Set([...k,...m].map(w)),A=D=>D>="0"&&D<="9",O=D=>/\s/.test(D),P=D=>/[)"'\]\}Â»â€]/.test(D),G=h.length,Z=[];let me="",x=0;function $(D){const U=Math.max(0,D-15),he=w(h.slice(U,D));for(const ee of E)if(he.endsWith(ee))return!0;if(h[D]==="."){let ee=D+1;for(;ee<G&&O(h[ee]);)ee++;if(ee+1<G&&/[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼]/.test(h[ee])&&h[ee+1]===".")return!0}return!1}for(;x<G;){const D=h[x];if(me+=D,D==="."||D==="!"||D==="?"){const U=h[x-1]||"",he=h[x+1]||"";if(!(D==="."&&A(U)&&A(he))&&!$(x)){let Q=x+1;for(;Q<G&&(P(h[Q])||h[Q]==="*");)me+=h[Q],Q++;const De=me.trim();for(De&&Z.push(De),me="";Q<G&&O(h[Q]);)Q++;x=Q;continue}}x++}return me.trim()&&Z.push(me.trim()),Z}const $e=z(null),Ke=Ga(null),Se=z(!1),Va={flipHorizontal:!0,maxNumBoxes:2,scoreThreshold:.6,iouThreshold:.5};async function La(){if(!await Bo($e.value))throw new Error("Kamerazugriff verweigert.");await new Promise(m=>{if($e.value.readyState>=2)return m();$e.value.onloadeddata=()=>m()})}async function Fa(){Ke.value=await Ro(Va)}async function kt(){if(!Se.value)return;const h=await Ke.value.detect($e.value);h.length>0&&(h.filter(m=>m.label==="open"&&m.score>.8).length>0&&(X.value=!0,q.value="OPEN",Y.value&&clearTimeout(Y.value),Y.value=setTimeout(()=>{X.value=!1,q.value="LISTENING"},2e3)),h.filter(m=>m.label==="closed"&&m.score>.8).length>0&&X.value&&(X.value=!1,q.value="CLOSED",Ft.reduceExecutions("recognition-pinch",()=>{M.value++,ue(),Y.value=setTimeout(()=>{q.value="LISTENING"},1e3)},1e3),console.log("preds",h))),await new Promise(m=>setTimeout(m,200)),Se.value&&kt()}async function ja(){if(!Se.value){q.value="LISTENING";try{await La(),Ke.value||await Fa(),Se.value=!0,kt()}catch(h){console.error(h)}}}function Ot(){q.value=null,Se.value&&(Se.value=!1,Ho($e.value))}return Ua(()=>{Ot()}),(h,m)=>{const k=H("v-app-bar-nav-icon"),w=H("v-icon"),E=H("v-list-item-title"),A=H("v-list-item"),O=H("v-divider"),P=H("v-chip"),G=H("v-list"),Z=H("v-menu"),me=H("v-app-bar"),x=H("v-alert"),$=H("v-btn"),D=H("v-img"),U=H("v-checkbox"),he=H("v-rating"),ee=H("v-container"),Q=H("v-col"),De=H("v-row"),Ra=H("v-table");return _(),L("div",null,[g(me,{collapse:"",elevation:0,color:"#6969695A",class:"no-print"},{prepend:S(()=>[g(Z,null,{activator:S(({props:T})=>[g(k,Ka(Ja(T)),null,16),I("div",null,[q.value==="OPEN"?(_(),te(w,{key:0,icon:"mdi-hand-back-left-outline",size:"30"})):V("",!0),q.value==="HEARING"?(_(),te(w,{key:1,icon:"mdi-ear-hearing",size:"30"})):V("",!0),q.value==="CLOSED"?(_(),te(w,{key:2,icon:"mdi-check-decagram-outline",size:"30"})):V("",!0),q.value==="LISTENING"?(_(),te(w,{key:3,icon:"mdi-record-rec",size:"30"})):V("",!0)])]),default:S(()=>[g(G,{class:"mt-2"},{default:S(()=>[g(A,{onClick:wt},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-knife",size:"20"}),R(" Schnibbelmodus "+se(N.value?"beenden":""),1)]),_:1})]),_:1}),pe.value?V("",!0):(_(),te(A,{key:0,onClick:m[0]||(m[0]=T=>Oa())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-microphone-message",size:"20"}),m[13]||(m[13]=R(" Sprachsteuerung aktivieren",-1))]),_:1})]),_:1})),pe.value?(_(),te(A,{key:1,onClick:m[1]||(m[1]=T=>Ia())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-microphone-message-off",size:"20"}),m[14]||(m[14]=R(" Sprachsteuerung beenden",-1))]),_:1})]),_:1})):V("",!0),Se.value?V("",!0):(_(),te(A,{key:2,onClick:m[2]||(m[2]=T=>ja())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-hand-okay",size:"20"}),m[15]||(m[15]=R(" Gestensteuerung aktivieren",-1))]),_:1})]),_:1})),Se.value?(_(),te(A,{key:3,onClick:m[3]||(m[3]=T=>Ot())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-hand-okay",size:"20"}),m[16]||(m[16]=R(" Gestensteuerung beenden",-1))]),_:1})]),_:1})):V("",!0),g(A,{onClick:va,disabled:M.value===-1},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-backup-restore",size:"20"}),m[17]||(m[17]=R(" Fortschritt zurÃ¼cksetzen",-1))]),_:1})]),_:1},8,["disabled"]),g(O),ye(i)?V("",!0):(_(),te(A,{key:4,onClick:m[4]||(m[4]=T=>ya(p.value)),disabled:p.value.planned},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-bowl-mix",size:"20"}),m[18]||(m[18]=R(" Einplanen",-1))]),_:1})]),_:1},8,["disabled"])),g(A,{onClick:m[5]||(m[5]=T=>St(ye(l)))},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-truck",size:"20"}),m[19]||(m[19]=R(" Zutaten einkaufen",-1))]),_:1})]),_:1}),g(A,{onClick:m[6]||(m[6]=T=>St(ye(l))),to:"/recipes/edit?id="+p.value.id},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-pencil",size:"20"}),m[20]||(m[20]=R(" Bearbeiten",-1))]),_:1})]),_:1},8,["to"]),g(O),g(A,null,{default:S(()=>[I("div",Uo,[g(w,{icon:"mdi-account-group",size:"20"}),m[21]||(m[21]=R(" Portionen ",-1))]),I("div",Ko,[(_(),L(_e,null,ke([1,2,3,4,5,6],T=>I("span",{key:T,class:"ml-1"},[g(P,{color:T===f.value?"indigo":null,"prepend-icon":"mdi-account",onClick:ce=>wa(T)},{default:S(()=>[R(se(T),1)]),_:2},1032,["color","onClick"])])),64))])]),_:1})]),_:1})]),_:1})]),_:1}),p.value&&p.value.draftInProgress?(_(),te(x,{key:0,type:"warning",color:"rgb(169, 209, 141)",onClick:je,style:{cursor:"pointer"},class:"mb-2"},{default:S(()=>[...m[22]||(m[22]=[R("Ein Entwurf wird gerade verarbeitet und anschlieÃŸend Ã¼bernommen. Bitte hier klicken um zu Aktualisieren.",-1)])]),_:1})):V("",!0),p.value?(_(),te(ee,{key:1,class:"pt-0"},{default:S(()=>[I("div",null,[I("div",Jo,[g($,{variant:"plain","prepend-icon":"mdi-arrow-left",onClick:Nt},{default:S(()=>[...m[23]||(m[23]=[R("ZurÃ¼ck",-1)])]),_:1})])]),I("div",Yo,[!p.value.imageInProgress&&p.value.imageUploaded?(_(),te(D,{key:0,height:"200",src:Ta(p.value),color:"grey",cover:""},null,8,["src"])):V("",!0),I("div",Zo,se(p.value.title),1)]),N.value?V("",!0):(_(),L("div",{key:0,class:"mt-6",onClick:Tt},[p.value.preheat?(_(),L("div",Xo,se(p.value.preheat),1)):V("",!0),(_(!0),L(_e,null,ke(Ce.value,(T,ce)=>(_(),L("div",{key:T.index},[I("div",null,[I("h2",{style:{color:"dimgray"},class:"pt-8",id:"section-"+ce},[T.sectionTitle.startsWith(T.index)?V("",!0):(_(),L("span",Mo,se(T.index),1)),R(" "+se(T.sectionTitle),1)],8,Qo)]),I("div",{style:{"font-size":"1.2em"},class:"mt-1",innerHTML:T.description,onClick:Ea,id:"sectionPart"},null,8,eu)]))),128))])),N.value?(_(),L("div",tu,[m[26]||(m[26]=I("h2",null,"Vorbereitungen",-1)),ye(i)?V("",!0):(_(),L("div",au,[g($,{onClick:Sa,variant:"plain",rounded:"",style:{"font-size":"0.7em"}},{default:S(()=>[...m[24]||(m[24]=[R("ZurÃ¼cksetzen",-1)])]),_:1})])),m[27]||(m[27]=I("h3",null,"Zutatenvorbereitungen",-1)),ye(bt).length===0?(_(),L("div",su," Keine Vorbereitungen nÃ¶tig. ")):V("",!0),(_(!0),L(_e,null,ke(ye(bt),T=>(_(),L("div",{class:"mt-1",key:T.name},[g(U,{modelValue:T.checked,"onUpdate:modelValue":ce=>T.checked=ce,"hide-details":"auto",density:"comfortable",label:T.name,onChange:vt},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),m[28]||(m[28]=I("h3",{class:"mt-3"},"Rezeptvorbereitungen",-1)),I("span",ru,"Dauer: "+se(ye(ga))+" Min.",1),(_(!0),L(_e,null,ke(ye(ba),T=>(_(),L("div",{class:"mt-1",key:T.name},[g(U,{modelValue:T.checked,"onUpdate:modelValue":ce=>T.checked=ce,"hide-details":"auto",density:"comfortable",label:T.name,onChange:vt},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),I("div",nu,[g($,{onClick:wt,color:"primary",variant:"outlined",rounded:""},{default:S(()=>[...m[25]||(m[25]=[R("Schnibbelmodus beenden",-1)])]),_:1})])])):V("",!0),I("div",iu,[ye(i)?V("",!0):(_(),L("div",ou,[m[29]||(m[29]=I("span",{style:{"font-size":"1.6em"}},"Wie gut hat das Essen geschmeckt?",-1)),I("div",uu,[g(he,{"onUpdate:modelValue":[_a,m[7]||(m[7]=T=>p.value.rating=T)],hover:"",length:"5",size:"30",modelValue:p.value.rating,"active-color":"primary"},null,8,["modelValue"])])])),I("div",lu,[g($,{variant:"text","prepend-icon":"mdi-arrow-left",style:{"font-size":"1.1em"},onClick:Nt},{default:S(()=>[...m[30]||(m[30]=[R("ZurÃ¼ck zur Ãœbersicht",-1)])]),_:1})])]),m[31]||(m[31]=I("div",{style:{height:"600px"}},null,-1))]),_:1})):V("",!0),c.value?(_(),L("div",pu,[I("div",mu,[Ae.value?(_(),L("div",cu,[I("div",du,[g(De,{align:"center"},{default:S(()=>[g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...m[32]||(m[32]=[R(" Das Rezept ist fÃ¼r heute geplant. Soll es auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:m[8]||(m[8]=T=>Ae.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...m[33]||(m[33]=[R(" Nein ",-1)])]),_:1}),g($,{onClick:Ge,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[R(" Ja ("+se(qe.value)+") ",1)]),_:1})]),_:1})]),_:1})])])):V("",!0),Ee.value?(_(),L("div",fu,[I("div",hu,[g(De,{align:"center"},{default:S(()=>[g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...m[34]||(m[34]=[R(" Es wurde ein anderes Rezept geplant. Soll stattdessen dieses auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:m[9]||(m[9]=T=>Ee.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...m[35]||(m[35]=[R(" Nein ",-1)])]),_:1}),g($,{onClick:Ge,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[...m[36]||(m[36]=[R(" Ja ",-1)])]),_:1})]),_:1})]),_:1})])])):V("",!0),b.value?(_(),L("div",yu,[g(ee,{"max-width":"400"},{default:S(()=>[g(Ra,null,{default:S(()=>[I("tbody",null,[(_(!0),L(_e,null,ke(c.value,T=>(_(),L("tr",{key:T.name},[I("td",null,[T.amount?(_(),L("span",gu,se(T.amount),1)):V("",!0),m[37]||(m[37]=R()),T.unit?(_(),L("span",bu,se(T.unit),1)):V("",!0)]),I("td",null,se(T.name),1)]))),128))])]),_:1})]),_:1})])):V("",!0),I("div",null,[d.value&&d.value.length>0?(_(),L("div",Nu,[I("div",null,[g($,{variant:"text",elevation:"0",disabled:"","prepend-icon":"mdi-timer-play-outline"},{default:S(()=>[...m[38]||(m[38]=[R("Stoppuhren",-1)])]),_:1})]),(_(!0),L(_e,null,ke(d.value,T=>(_(),L("div",{key:T.title,class:"my-1"},[g(O,{class:"mb-1"}),g(De,{align:"center"},{default:S(()=>[g($,{icon:"mdi-close",onClick:ce=>$a(T.id),variant:"text"},null,8,["onClick"]),g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[R(se(T.title),1)]),_:2},1024),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:ce=>Ca(T),icon:"mdi-minus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),g($,{onClick:ce=>za(T),icon:"mdi-plus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),I("span",vu,se(Aa(T.remainingSeconds)),1),T.timerStarted?V("",!0):(_(),te($,{key:0,onClick:ce=>Da(T),icon:"mdi-play-circle-outline",class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0"},null,8,["onClick"])),T.timerStarted?(_(),te($,{key:1,onClick:ce=>Pa(T),class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0",icon:""},{default:S(()=>[T.isPaused?(_(),L("span",Tu,[g(w,{icon:"mdi-play-circle-outline"})])):V("",!0),T.isPaused?V("",!0):(_(),L("span",Su,[g(w,{icon:"mdi-pause-circle-outline"})]))]),_:2},1032,["onClick"])):V("",!0)]),_:2},1024)]),_:2},1024)]))),128))])):V("",!0),I("div",wu,[I("span",_u,[g($,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:ka,disabled:!fe.value,elevation:"0","prepend-icon":"mdi-arrow-left-top"},null,8,["disabled"])]),I("span",ku,[g($,{color:"rgb(191, 231, 210)",style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",disabled:!C.value,onClick:Tt,elevation:"0","prepend-icon":"mdi-skip-forward"},{default:S(()=>[...m[39]||(m[39]=[R("NÃ¤chster Schritt",-1)])]),_:1},8,["disabled"])]),I("span",Ou,[g($,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:m[10]||(m[10]=T=>b.value=!b.value),elevation:"0","prepend-icon":"mdi-food-apple-outline"})])])])])])):V("",!0),m[40]||(m[40]=I("div",{style:{display:"none"}},[I("iframe",{id:"scFrame",src:"/tfjs.html",allow:"microphone"})],-1)),g(Xa,{onResult:m[11]||(m[11]=T=>v.value=T)}),g(Rn,{onResult:m[12]||(m[12]=T=>B.value=T)}),I("video",{ref_key:"videoEl",ref:$e,autoplay:"",playsinline:"",muted:"",style:{display:"none"}},null,512)])}}},Eu=Mt(Iu,[["__scopeId","data-v-e066fa28"]]),Cu={__name:"index",setup(a){const e=mt(),t=Ya();z(!1);const s=e.query.id;return ct(async()=>{s||t.push("/recipes")}),(i,n)=>(_(),te(Eu))}};export{Cu as default};

import{_ as oa,O as ua,K as la,r as D,u as pa,P as ft,o as gt,g as B,Q,y as w,C as S,B as g,z as I,x as z,T as _e,U as ke,R as P,A as ae,D as F,L as xt,Y as Za,N as Xa,Z as Qa,$ as Ma,k as Me,s as es,e as ts,S as he,a0 as as,a1 as ss,J as rs}from"./Dc-SAfZz.js";import{G as Vt,R as fe,I as ns}from"./CnbI8feb.js";import{I as is}from"./JUHQS_kN.js";import{_ as os,a as L,e as bt,g as us,c as ls,I as ma,b as ps,i as ms,m as cs,o as ye,d as ds,E as ie,F as Lt,f as K,h as at,A as hs,B as ys,D as fs,L as gs,M as bs,r as te,j as Ns,T as Ft,w as vs,v as Ts,S as Ss,k as ws,G as _s,s as ks,l as ca,n as da,p as Os,q as Is,t as Es,u as As,x as $s,y as Ds,z as jt,C as Rt,H as Ps,J as zs,K as Cs,N as xs,O as Vs,P as Ls,Q as Fs,R as ge,U as js,V as Rs,W as Bs,X as Hs,Y as Ws,Z as qs,$ as Us,a0 as Gs,a1 as Ks,a2 as Js,a3 as Ys,a4 as Zs,a5 as ha,a6 as Xs,a7 as Qs,a8 as Ms,a9 as er,aa as tr,ab as ar,ac as sr,ad as rr,ae as nr,af as ir,ag as or,ah as ur,ai as lr,aj as pr,ak as mr,al as cr,am as dr,an as hr,ao as yr,ap as fr,aq as gr,ar as br,as as Nr,at as vr,au as Tr,av as Sr,aw as wr,ax as _r,ay as kr,az as Or,aA as Ir,aB as Er,aC as Ar,aD as $r,aE as Dr,aF as Pr,aG as zr,aH as Cr,aI as ve,aJ as Oe,aK as Ue,aL as je,aM as Nt,aN as Re,aO as W,aP as vt,aQ as xr,aR as Vr,aS as Lr,aT as Fr,aU as jr,aV as Rr,aW as Br,aX as Hr,aY as Wr,aZ as qr,a_ as Ur,a$ as ya,b0 as Gr,b1 as Kr,b2 as Jr,b3 as Yr,b4 as Zr,b5 as Xr,b6 as Qr,b7 as Fe,b8 as Ee,b9 as Bt,ba as Mr,bb as Ht,bc as en,bd as tn,be as an,bf as sn,bg as rn,bh as nn,bi as on,bj as un,bk as ln,bl as pn,bm as mn,bn as cn,bo as dn,bp as hn,bq as yn,br as fn,bs as Wt,bt as gn,bu as bn,bv as Nn,bw as vn,bx as Tn,by as Sn,bz as wn,bA as _n,bB as kn,bC as On,bD as In,bE as st,bF as En,bG as qt,bH as Ut,bI as An,bJ as $n,bK as Dn,bL as Pn,bM as zn,bN as Cn,bO as xn,bP as Vn,bQ as Ln,bR as Fn,bS as jn,bT as rt,bU as Rn,bV as Bn,bW as Hn,bX as fa,bY as et,bZ as Wn,b_ as Gt,b$ as qn}from"./BPyvoQ0X.js";const Un={class:"mt-3"},Gn={style:{"font-size":"1.6em"}},Kn={key:0,style:{"font-size":"1.3em","font-style":"italic"},class:"ml-4"},Jn={__name:"TimerDialog",emits:["result"],setup(a,{emit:e}){ua();const t=la();D(t.authInfo);const s=e;pa(),ft().params.userId;const n=D(!1),o=D(null),u=D(null),l=D(!1),p=D([]);let c=null;gt(async()=>{s("result",async f=>(p.value=f,l.value=!1,c=new Audio("/audio/alert.mp3"),c.loop=!0,c.play(),setTimeout(()=>{h()},1e4),n.value=!0,new Promise((b,N)=>{o.value=b,u.value=N})))});function h(){c&&(c.pause(),c.currentTime=0,l.value=!0)}function d(){h(),n.value=!1,o.value(!1)}return(f,b)=>{const N=B("v-card-title"),v=B("v-divider"),j=B("v-card-text"),J=B("v-btn"),C=B("v-card-actions"),Te=B("v-card"),re=B("v-dialog");return w(),Q(re,{"max-width":"600",persistent:"",modelValue:n.value,"onUpdate:modelValue":b[0]||(b[0]=V=>n.value=V)},{default:S(()=>[g(Te,{style:{"background-color":"#fcfaf7"},class:"pa-4"},{default:S(()=>[g(N,null,{default:S(()=>[...b[1]||(b[1]=[I("h2",null,"Zeit abgelaufen!",-1)])]),_:1}),g(j,null,{default:S(()=>[b[3]||(b[3]=I("div",{style:{width:"100%"},class:"text-center"},[I("div",{class:"vibrate"},[I("img",{alt:"bellring",src:os,style:{width:"300px",height:"300px"},class:"mt-2"})])],-1)),g(v),I("div",Un,[b[2]||(b[2]=I("h3",null,"Folgende Timer sind abgelaufen:",-1)),(w(!0),z(_e,null,ke(p.value,V=>(w(),z("div",{key:V.id},[I("span",Gn,"- "+ae(V.title),1),V.descriptionTextAfter?(w(),z("div",Kn,ae(V.descriptionTextAfter),1)):P("",!0)]))),128))])]),_:1}),g(C,null,{default:S(()=>[g(J,{onClick:h,rounded:"",variant:"outlined",disabled:l.value},{default:S(()=>[...b[4]||(b[4]=[F(" Wecker stoppen ",-1)])]),_:1},8,["disabled"]),g(J,{onClick:d,rounded:"",variant:"outlined",color:"red"},{default:S(()=>[...b[5]||(b[5]=[F(" SchlieÃŸen ",-1)])]),_:1})]),_:1})]),_:1})]),_:1},8,["modelValue"])}}},Yn=oa(Jn,[["__scopeId","data-v-38b0a021"]]);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(a,e,t,s){o(a),t=t??0,s=s??1,u(t,s);let i=0;const n=l=>(l.then(p=>{const c=t+ ++i/a.length*(s-t);return e(c),p}),l);function o(l){L(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function u(l,p){L(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),L(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),L(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}return Promise.all(a.map(n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Zn(a,e){e==null&&(e={});const t=e.fetchFunc==null?bt().platform.fetch:e.fetchFunc,s=a.map(h=>t(h,e.requestInit,{isBinary:!0})),u=(e.onProgress==null?await Promise.all(s):await Kt(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(u):await Kt(u,e.onProgress,.5,1)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xn="application/octet-stream",Qn="application/json";class Tt{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(L(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=bt().platform.fetch,L(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&L(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:s};e.signature!=null&&(i.signature=e.signature),e.userDefinedMetadata!=null&&(i.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(i.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(i)],{type:Qn}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Xn}),"model.weights.bin");const n=await this.fetch(this.path,t);if(n.ok)return{modelArtifactsInfo:us(e),responses:[n]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${n.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let N=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?N+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":N+=" Please make sure the server is serving valid JSON for this request.",new Error(N)}const s=t.modelTopology,i=t.weightsManifest,n=t.generatedBy,o=t.convertedBy,u=t.format,l=t.signature,p=t.userDefinedMetadata;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let c,h;i!=null&&([c,h]=await this.loadWeights(i));const d={modelTopology:s,weightSpecs:c,weightData:h,generatedBy:n,convertedBy:o,format:u};l!=null&&(d.signature=l),p!=null&&(d.userDefinedMetadata=p);const f=t.modelInitializer;return f&&(d.modelInitializer=f),d}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=Mn(t),n=this.weightPathPrefix||s,o=[];for(const c of e)o.push(...c.weights);const u=[],l=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):u.push(n+h+i);this.weightUrlConverter&&u.push(...await Promise.all(l));const p=await Zn(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,ls(p)]}}Tt.URL_SCHEME_REGEX=/^https?:\/\//;function Mn(a){const e=a.lastIndexOf("/"),t=a.lastIndexOf("?"),s=a.substring(0,e),i=t>e?a.substring(t):"";return[s+"/",i]}function Jt(a){return a.match(Tt.URL_SCHEME_REGEX)!=null}const ga=(a,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(a)?t=a.every(s=>Jt(s)):t=Jt(a),t)return ba(a,e)}return null};ma.registerSaveRouter(ga);ma.registerLoadRouter(ga);function ba(a,e){return new Tt(a,e)}function Yt(a,e){return ba(a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(a,e,t){if(ps(a),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ms(a,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return cs(a,e,s,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ze;function ti(a,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(a==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,n=!1,o=!1,u=!1;if(a.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&a instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement)n=!0;else if(a.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&a instanceof ImageBitmap)u=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${a.constructor.name}`);if(i&&i&&a.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(ds(Lt,ie.backendName)!=null){const b={pixels:a},N={numChannels:e};return ie.runKernel(Lt,b,N)}const[p,c]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height];let h;o?h=a.getContext("2d").getImageData(0,0,p,c).data:s||t?h=a.data:(n||i||u)&&(ze==null&&(ze=document.createElement("canvas").getContext("2d")),ze.canvas.width=p,ze.canvas.height=c,ze.drawImage(a,0,0,p,c),h=ze.getImageData(0,0,p,c).data);let d;if(e===4)d=new Int32Array(h);else{const b=p*c;d=new Int32Array(b*e);for(let N=0;N<b;N++)for(let v=0;v<e;++v)d[N*e+v]=h[N*4+v]}return ei(d,[c,p,e],"int32")}const ai=ye({fromPixels_:ti});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function si(a){L(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),L(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);const e=a.map((i,n)=>K(i,`tensors${n}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!at(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ie.runKernel(hs,s)}const ri=ye({addN_:si});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ni(a,e,t){const s=K(a,"x","bincount"),i=K(e,"weights","bincount");L(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const n={x:s,weights:i},o={size:t};return ie.runKernel(ys,n,o)}const ii=ye({bincount_:ni});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oi(a,e,t,s=!1){const i=K(a,"x","denseBincount"),n=K(e,"weights","denseBincount");L(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),L(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),L(t>=0,()=>`size must be non-negative, but got ${t}.`),L(n.size===i.size||n.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${n.shape}.`);const o={x:i,weights:n},u={size:t,binaryOutput:s};return ie.runKernel(fs,o,u)}const ui=ye({denseBincount_:oi});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function li(a,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:a,stop:e,num:t};return ie.runKernel(gs,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(a,e,t,s,i=!1){const o={x:K(a,"x","maxPoolWithArgmax")},u={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},l=ie.runKernel(bs,o,u);return{result:l[0],indexes:l[1]}}const mi=ye({maxPoolWithArgmax_:pi});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ci(a,e,t,s=!1){const i=K(a,"logits","multinomial"),n=i.size,o=i.rank;if(n<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${n}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?te(i,[1,-1]):i},p={numSamples:e,seed:t,normalized:s},c=ie.runKernel(Ns,l,p);return o===1?te(c,[c.size]):c}const di=ye({multinomial_:ci});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function hi(a,e){const t=K(a,"x","setdiff1d"),s=K(e,"y","setdiff1d");L(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),L(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),L(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),n=await s.data(),o=new Set(n);let u=0;for(let c=0;c<i.length;c++)o.has(i[c])||u++;const l=new Ft([u],t.dtype),p=new Ft([u],"int32");for(let c=0,h=0;c<i.length;c++)o.has(i[c])||(l.values[h]=i[c],p.values[h]=c,h++);return[l.toTensor(),p.toTensor()]}const yi=hi;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fi(a){const e=K(a,"condition","whereAsync","bool"),t=await e.data(),s=vs(e.shape,t);return a!==e&&e.dispose(),s}const gi=fi;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bi(a,e,t){const s=K(a,"indices","scatterND","int32"),i=K(e,"updates","scatterND");Ts(i,s,t);const n={indices:s,updates:i},o={shape:t};return ie.runKernel(Ss,n,o)}const Ni=ye({scatterND_:bi});function vi(a,e,t,s){if(a.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);const i=a.rank>0?a.shape[0]:1,n=a.rank>1?a.shape[1]:1;if(t.length!==n)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${n}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ti(a,e,t,s=0){const i=K(a,"sparseIndices","sparseToDense","int32"),n=K(e,"sparseValues","sparseToDense"),o=K(s,"defaultValue","sparseToDense",n.dtype);vi(i,n,t,o);const u={sparseIndices:i,sparseValues:n,defaultValue:o},l={outputShape:t};return ie.runKernel(ws,u,l)}const Na=ye({sparseToDense_:Ti});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Si(a,e){const t=K(e,"indices","gatherND","int32"),i={params:K(a,"x","gatherND"),indices:t};return ie.runKernel(_s,i)}const wi=ye({gatherND_:Si});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _i({x:a,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:n=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:c}){if(ks(ie.state.gradientDepth,l)===!1){let re=ca(a,e,t,s,i,n,o);return u!=null&&(re=da(re,u)),Os(re,l,p,c)}const h=K(a,"x","depthwiseConv2d"),d=K(e,"filter","depthwiseConv2d");let f=h,b=!1;h.rank===3&&(b=!0,f=te(h,[1,h.shape[0],h.shape[1],h.shape[2]])),L(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),L(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),L(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),n==null&&(n=[1,1]),L(Is(t,n),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${n}'`),o!=null&&L(Es(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const N=As(f.shape,d.shape,t,n,s,o,!0);let v;u!=null&&(v=K(u,"bias","fused conv2d"),[v]=$s(v,h),Ds(N.outShape,v.shape));let j;p!=null&&(j=K(p,"prelu weights","fused depthwiseConv2d"));const J=(re,V)=>{L(Ps(n),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${n}'`);const[le,U,Y,X]=V,Ae=zs(re,Y,l),Ie=Cs(U.shape,Ae,le,t,s,n,o),M=xs(U,Ae,le.shape,t,s,n,o);if(X!=null){const xe=Vs(v,Ae);return[Ie,M,xe]}return[Ie,M]},C={x:f,filter:d,bias:v,preluActivationWeights:j},Te={strides:t,pad:s,dataFormat:i,dilations:n,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return u==null?jt((V,le,U)=>{let Y=ie.runKernel(Rt,C,Te);return U([le,V,Y]),b&&(Y=te(Y,[Y.shape[1],Y.shape[2],Y.shape[3]])),{value:Y,gradFunc:J}})(f,d):jt((V,le,U,Y)=>{let X=ie.runKernel(Rt,C,Te);return Y([le,V,X,U]),b&&(X=te(X,[X.shape[1],X.shape[2],X.shape[3]])),{value:X,gradFunc:J}})(f,d,v)}const ki=ye({fusedDepthwiseConv2d_:_i});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oi={};function va(a){return Oi[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,e,t,s,i){const n=e.inputParams[a];if(n&&n.inputIndexStart!==void 0){const u=n.inputIndexStart,l=n.inputIndexEnd===0?void 0:n.inputIndexEnd===void 0?u+1:n.inputIndexEnd;if(n.type==="tensor")return se(e.inputNames[n.inputIndexStart],t,s,i);if(n.type==="tensors")return e.inputNames.slice(u,l).map(d=>se(d,t,s,i));const p=se(e.inputNames.slice(u)[0],t,s,i),c=p.dataSync();return n.type==="number"?c[0]:Ls(p.shape,c)}const o=e.attrParams[a];return o&&o.value}function se(a,e,t,s){const[i,n]=ne(a);if(s!=null){const u=s.getHashTableHandleByName(i);if(u!=null)return u}const o=t.currentContextIds.find(u=>!!e[Ge(i,u)]);return o!==void 0?e[Ge(i,o)][n]:void 0}function Ii(a,e,t){return e[Ge(a,t.currentContextId)]}function be(a,e){const[t,s]=ne(a);return[Ge(t,e&&e.currentContextId),s]}function Ge(a,e){return e?`${a}-${e}`:a}function ne(a){const e=a.split(":");return e.length===1?[a,0]:[e[0],Number(e[e.length-1])]}function qe(a,e,t){let s=r("pad",a,e,t);if(s==="explicit"){s=r("explicitPaddings",a,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let n=0;n<4;n++)i[n][0]=s[n*2],i[n][1]=s[n*2+1];return i}return s}function Ne(a){return a.kept?a:Fs(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ei=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ai=Object.freeze(Object.defineProperty({__proto__:null,json:Ei},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $i=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Di=Object.freeze(Object.defineProperty({__proto__:null,json:$i},Symbol.toStringTag,{value:"Module"})),Pi=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],zi=Object.freeze(Object.defineProperty({__proto__:null,json:Pi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ci=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],xi=Object.freeze(Object.defineProperty({__proto__:null,json:Ci},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Li=Object.freeze(Object.defineProperty({__proto__:null,json:Vi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ji=Object.freeze(Object.defineProperty({__proto__:null,json:Fi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ri=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Bi=Object.freeze(Object.defineProperty({__proto__:null,json:Ri},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hi=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Wi=Object.freeze(Object.defineProperty({__proto__:null,json:Hi},Symbol.toStringTag,{value:"Module"})),qi=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Ui=Object.freeze(Object.defineProperty({__proto__:null,json:qi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gi=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Ki=Object.freeze(Object.defineProperty({__proto__:null,json:Gi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ji=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Yi=Object.freeze(Object.defineProperty({__proto__:null,json:Ji},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zi=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Xi=Object.freeze(Object.defineProperty({__proto__:null,json:Zi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qi=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Mi=Object.freeze(Object.defineProperty({__proto__:null,json:Qi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eo=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],to=Object.freeze(Object.defineProperty({__proto__:null,json:eo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],so=Object.freeze(Object.defineProperty({__proto__:null,json:ao},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],no=Object.freeze(Object.defineProperty({__proto__:null,json:ro},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const io=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}],oo=Object.freeze(Object.defineProperty({__proto__:null,json:io},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zt{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Ai,Di,zi,xi,Li,ji,Bi,Yi,Ki,Wi,Xi,Mi,to,so,no,oo,Ui],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(e,t={}){const s=e.node,i=[],n=[],o=[],u=s.reduce((N,v)=>(N[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?i.push(N[v.name]):v.op==="Const"?n.push(N[v.name]):(v.input==null||v.input.length===0)&&o.push(N[v.name]),N),{});let l=[];const p=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(u);d.forEach(N=>{const v=u[N];v.inputNames.forEach(j=>{const[J]=be(j);v.inputs.push(u[J]),u[J].children.push(v)})}),Object.keys(h).length===0?d.forEach(N=>{const v=u[N];v.children.length===0&&p.push(v)}):Object.keys(h).forEach(N=>{const[v]=be(N),j=u[v];j!=null&&(j.signatureKey=h[N],p.push(j))}),Object.keys(c).length>0?Object.keys(c).forEach(N=>{const[v]=be(N),j=u[v];j&&(j.signatureKey=c[N],l.push(j))}):l=i;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((N,v)=>(N[v.signature.name]=this.mapFunction(v),N),{}));const b={nodes:u,inputs:l,outputs:p,weights:n,placeholders:i,signature:t,functions:f};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=va(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.substr(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,n)=>(i[n.name]={type:n.type,inputIndexStart:n.start,inputIndexEnd:n.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,n)=>{const o=n.type;let u;switch(n.type){case"string":u=nt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=nt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":u=ct(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ct(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":u=ot(e.attr,n.tfName,n.defaultValue||0),u===void 0&&n.tfDeprecatedName&&(u=ot(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":u=mt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=mt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":u=it(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=it(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":u=ht(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ht(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":u=pt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=pt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":u=dt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=dt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":u=ut(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ut(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":u=lt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=lt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":u=Xt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=Xt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return i[n.name]={value:u,type:o},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let n={};t!=null&&(n=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&i.push(h[d.name]),h),{}));const o=[],u=[];e.signature.inputArg.forEach(h=>{const[d]=be(h.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:St(h.type),type:"dtype"}},children:[]};f.signatureKey=h.name,o.push(f),n[d]=f}),Object.keys(n).forEach(h=>{const d=n[h];d.inputNames.forEach(f=>{const[b]=be(f);d.inputs.push(n[b]),n[b].children.push(d)})});const p=e.ret;e.signature.outputArg.forEach(h=>{const[d,f]=be(p[h.name]),b=n[d];b!=null&&(b.defaultOutput=f,u.push(b))});const c=this.mapArgsToSignature(e);return{nodes:n,inputs:o,outputs:u,weights:i,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function uo(a){const e=bt().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Ta(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):uo(a);return e?t:t.toLowerCase()}function nt(a,e,t,s=!1){const i=a[e];return i!=null?Ta(i.s,s):t}function it(a,e,t){const s=a[e];return s?s.b:t}function ot(a,e,t){const s=a[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function St(a){switch(typeof a=="string"&&(a=ge[a]),a){case ge.DT_FLOAT:return"float32";case ge.DT_INT32:case ge.DT_INT64:case ge.DT_INT8:case ge.DT_UINT8:return"int32";case ge.DT_BOOL:return"bool";case ge.DT_DOUBLE:return"float32";case ge.DT_STRING:return"string";default:return null}}function Xt(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function ut(a,e,t){const s=a[e];return s&&s.type?St(s.type):t}function lt(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(i=>St(i)):t}function Sa(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function pt(a,e,t){const s=a[e];return s&&s.shape?Sa(s.shape):t}function mt(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function ct(a,e,t,s=!1){const i=a[e];return i&&i.list&&i.list.s?i.list.s.map(n=>Ta(n,s)):t}function dt(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>Sa(i)):t}function ht(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lo{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,n)=>(i[n]=this.getAttr(n),i),{}))}getInput(e){return se(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return se(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return ot(this.node.rawAttrs,e,t);if(s.s!=null)return nt(this.node.rawAttrs,e,t);if(s.b!=null)return it(this.node.rawAttrs,e,t);if(s.shape!=null)return pt(this.node.rawAttrs,e,t);if(s.type!=null)return ut(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return mt(this.node.rawAttrs,e,t);if(s.list.s!=null)return ct(this.node.rawAttrs,e,t);if(s.list.shape!=null)return dt(this.node.rawAttrs,e,t);if(s.list.b!=null)return ht(this.node.rawAttrs,e,t);if(s.list.type!=null)return lt(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const po=(a,e,t)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[da(r("a",a,e,t),r("b",a,e,t))];case"AddN":return[ri(r("tensors",a,e,t))];case"FloorMod":case"Mod":return[Js(r("a",a,e,t),r("b",a,e,t))];case"Mul":return[Ks(r("a",a,e,t),r("b",a,e,t))];case"RealDiv":case"Div":return[Gs(r("a",a,e,t),r("b",a,e,t))];case"DivNoNan":return[Us(r("a",a,e,t),r("b",a,e,t))];case"FloorDiv":return[qs(r("a",a,e,t),r("b",a,e,t))];case"Sub":return[Ws(r("a",a,e,t),r("b",a,e,t))];case"Minimum":return[Hs(r("a",a,e,t),r("b",a,e,t))];case"Maximum":return[Bs(r("a",a,e,t),r("b",a,e,t))];case"Pow":return[Rs(r("a",a,e,t),r("b",a,e,t))];case"SquaredDifference":return[js(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=(a,e,t)=>{switch(a.op){case"Abs":case"ComplexAbs":return[Cr(r("x",a,e,t))];case"Acos":return[zr(r("x",a,e,t))];case"Acosh":return[Pr(r("x",a,e,t))];case"Asin":return[Dr(r("x",a,e,t))];case"Asinh":return[$r(r("x",a,e,t))];case"Atan":return[Ar(r("x",a,e,t))];case"Atan2":return[Er(r("x",a,e,t),r("y",a,e,t))];case"Atanh":return[Ir(r("x",a,e,t))];case"Ceil":return[Or(r("x",a,e,t))];case"Complex":return[kr(r("real",a,e,t),r("imag",a,e,t))];case"Cos":return[_r(r("x",a,e,t))];case"Cosh":return[wr(r("x",a,e,t))];case"Elu":return[Sr(r("x",a,e,t))];case"Erf":return[Tr(r("x",a,e,t))];case"Exp":return[vr(r("x",a,e,t))];case"Expm1":return[Nr(r("x",a,e,t))];case"Floor":return[br(r("x",a,e,t))];case"Log":return[gr(r("x",a,e,t))];case"Log1p":return[fr(r("x",a,e,t))];case"Imag":return[yr(r("x",a,e,t))];case"Neg":return[hr(r("x",a,e,t))];case"Reciprocal":return[dr(r("x",a,e,t))];case"Real":return[cr(r("x",a,e,t))];case"Relu":return[mr(r("x",a,e,t))];case"Round":return[pr(r("x",a,e,t))];case"Selu":return[lr(r("x",a,e,t))];case"Sigmoid":return[ur(r("x",a,e,t))];case"Sin":return[or(r("x",a,e,t))];case"Sign":return[ir(r("x",a,e,t))];case"Sinh":return[nr(r("x",a,e,t))];case"Softplus":return[rr(r("x",a,e,t))];case"Sqrt":return[sr(r("x",a,e,t))];case"Square":return[ar(r("x",a,e,t))];case"Tanh":return[tr(r("x",a,e,t))];case"Tan":return[er(r("x",a,e,t))];case"ClipByValue":return[Ms(r("x",a,e,t),r("clipValueMin",a,e,t),r("clipValueMax",a,e,t))];case"Relu6":return[Qs(r("x",a,e,t))];case"Rsqrt":return[Xs(se(a.inputNames[0],e,t))];case"Prod":return[ha(r("x",a,e,t),r("axes",a,e,t))];case"LeakyRelu":return[Zs(r("x",a,e,t),r("alpha",a,e,t))];case"Prelu":return[Ys(r("x",a,e,t),r("alpha",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ue(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){L(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const i=a[s],n=e[s];L(i<0||n<0||i===n,()=>t+` Shapes ${a} and ${e} must match`)}}}function Qt(a){return!(typeof a=="number"||a.some(e=>e<0))}function Le(a,e,t){let s=yt(a,t);const i=!Qt(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(n=>{s=yt(n.shape,s)}),!Qt(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function yt(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const i=a[s],n=e[s];if(i>=0&&n>=0&&i!==n)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=i>=0?i:n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class co{constructor(e,t,s,i,n,o,u){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=n,this.dynamicSize=o,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=ve(0),Oe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ue(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Oe(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Ue([],[0].concat(this.elementShape));const s=this.readMany(e);return ue(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),je(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ue([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return ue(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Nt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Re(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const n=s===0?0:t.size/s,o=[];W(()=>{t=te(t,[1,s,n]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],h=[1,e[l],n];o[l]=te(vt(t,c,h),this.elementShape)}return o});const u=[];for(let l=0;l<e.length;l++)u[l]=l;this.writeMany(u,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ce{constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(n=>{if(s!==n.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${n.dtype}`);ue(t,n.shape,"TensorList shape mismatch: "),Oe(n)}),this.idTensor=ve(0),this.maxNumElements=i,Oe(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ce([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);ue(e,this.elementShape,"TensorList shape mismatch: ");const i=Le(this.elementShape,this.tensors,e);return W(()=>{const n=this.tensors.map(o=>te(o,i));return je(n,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Le(this.elementShape,this.tensors,e),i=this.tensors.pop();return ue(i.shape,e,"TensorList shape mismatch: "),te(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ue(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Oe(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ue(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Le(this.elementShape,this.tensors,t);return te(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ue(this.elementShape,t.shape,"TensorList shape mismatch: "),Oe(t),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ue(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Le(this.elementShape,this.tensors,s);return e.length===0?Ue([],[0].concat(i)):W(()=>{const n=e.map(o=>te(this.tensors[o],i));return je(n,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ue(this.elementShape,t,"TensorList shape mismatch: ");const s=Le(this.elementShape,this.tensors,t);return this.size()===0?Ue([],[0].concat(s)):W(()=>{const i=this.tensors.map(n=>te(n,s));return Nt(i,0)})}}function ho(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const i=a.shape.slice(1);ue(i,e,"TensorList shape mismatch: ");const n=Re(a);return new Ce(n,e,s)}function yo(a,e,t){return new Ce([],a,e,t)}function fo(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const n=new Ce([],t,a.dtype,s),o=Re(a,0);return e.forEach((u,l)=>{n.setItem(u,o[l])}),n}function go(a,e,t){let s=0;const i=e.map(c=>(s+=c,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const n=a.shape.slice(1),o=yt(n,t),u=s===0?0:a.size/s,l=W(()=>{const c=[];a=te(a,[1,s,u]);for(let h=0;h<e.length;++h){const f=[0,h===0?0:i[h-1],0],b=[1,e[h],u];c[h]=te(vt(a,f,b),o)}return a.dispose(),c}),p=new Ce([],t,a.dtype,e.length);for(let c=0;c<l.length;c++)p.setItem(c,l[c]);return p}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=r("thenBranch",a,e,t),i=r("elseBranch",a,e,t),n=r("cond",a,e,t),o=r("args",a,e,t);return(await n.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=r("body",a,e,t),i=r("cond",a,e,t),n=r("args",a,e,t),o=await t.functionMap[i].executeFunctionAsync(n,t.tensorArrayMap,t.tensorListMap),u=n.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&u.indexOf(c.id)===-1&&c.dispose()});let p=n;for(;l[0];){const c=p;p=await t.functionMap[s].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);const h=p.map(f=>f.id);c.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()});const d=await t.functionMap[i].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()})}return p}case"LoopCond":{const s=r("pred",a,e,t);return[Ne(s)]}case"Switch":{const s=r("pred",a,e,t);let i=r("data",a,e,t);return i.kept||(i=Ne(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=a.inputNames.find(i=>se(i,e,t)!==void 0);if(s){const i=se(s,e,t);return[Ne(i)]}return}case"Enter":{const s=r("frameName",a,e,t),i=r("tensor",a,e,t);return t.enterFrame(s),[Ne(i)]}case"Exit":{const s=r("tensor",a,e,t);return t.exitFrame(),[Ne(s)]}case"NextIteration":{const s=r("tensor",a,e,t);return t.nextIteration(),[Ne(s)]}case"TensorArrayV3":{const s=r("size",a,e,t),i=r("dtype",a,e,t),n=r("elementShape",a,e,t),o=r("dynamicSize",a,e,t),u=r("clearAfterRead",a,e,t),l=r("identicalElementShapes",a,e,t),p=r("name",a,e,t),c=new co(p,i,s,n,l,o,u);return t.addTensorArray(c),[c.idTensor,ve(1)]}case"TensorArrayWriteV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.write(i,n),[o.idTensor]}case"TensorArrayReadV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("dtype",a,e,t);return[t.getTensorArray(s.id).gather(i,n)]}case"TensorArrayScatterV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.scatter(i,n),[o.idTensor]}case"TensorArrayConcatV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id),n=r("dtype",a,e,t);return[i.concat(n)]}case"TensorArraySplitV3":{const s=r("tensorArrayId",a,e,t),i=r("tensor",a,e,t),n=r("lengths",a,e,t),o=t.getTensorArray(s.id);return o.split(n,i),[o.idTensor]}case"TensorArraySizeV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return[ve(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorList(s.id);return o.setItem(i,n),[o.idTensor]}case"TensorListGetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(i,n,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=r("indices",a,e,t),i=r("tensor",a,e,t),n=r("elementShape",a,e,t),o=r("numElements",a,e,t),u=fo(i,s,n,o);return t.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=r("elementShape",a,e,t),i=r("elementDType",a,e,t);let n;a.op==="TensorListReserve"?n="numElements":n="maxNumElements";const o=r(n,a,e,t),u=yo(s,i,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=r("tensorListId",a,e,t),i=r("indices",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).gather(i,o,n)]}case"TensorListStack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=r("numElements",a,e,t);return[t.getTensorList(s.id).stack(i,n,o)]}case"TensorListFromTensor":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=ho(s,i,n);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const s=r("tensorListId",a,e,t),i=t.getTensorList(s.id),n=r("dtype",a,e,t),o=r("elementShape",a,e,t);return[i.concat(n,o)]}case"TensorListPushBack":{const s=r("tensorListId",a,e,t),i=r("tensor",a,e,t),n=t.getTensorList(s.id);return n.pushBack(i),[n.idTensor]}case"TensorListPopBack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(i,n)]}case"TensorListSplit":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("lengths",a,e,t),o=go(s,n,i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(a,e,t){const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=s==="fusedbatchnorm",l=r("numArgs",a,e,t);if(n){if(o&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const p=r("strides",a,e,t),c=qe(a,e,t),h=r("dataFormat",a,e,t).toUpperCase(),d=r("dilations",a,e,t),[f,b]=r("args",a,e,t),N=r("leakyreluAlpha",a,e,t);return{stride:p,pad:c,dataFormat:h,dilations:d,biasArg:f,preluArg:b,activationFunc:i,leakyreluAlpha:N}}const No=(a,e,t)=>{switch(a.op){case"Conv1D":{const s=r("stride",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilation",a,e,t);return[qr(r("x",a,e,t),r("filter",a,e,t),s,i,n,o)]}case"Conv2D":{const s=r("strides",a,e,t),i=qe(a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[Wr(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,n,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:c}=Mt(a,e,t);return[Hr({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:c}=Mt(a,e,t);return[ki({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=r("outputShape",a,e,t),i=r("strides",a,e,t),n=qe(a,e,t);return[Br(r("x",a,e,t),r("filter",a,e,t),s,[i[1],i[2]],n)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=r("strides",a,e,t),i=qe(a,e,t),n=r("dilations",a,e,t),o=r("dataFormat",a,e,t).toUpperCase();return[ca(r("input",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,o,[n[1],n[2]])]}case"Conv3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[Rr(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2],s[3]],i,n,[o[1],o[2],o[3]])]}case"AvgPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[jr(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Fr(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t),o=r("includeBatchInIndex",a,e,t),{result:u,indexes:l}=mi(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i,o);return[u,l]}case"AvgPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Lr(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Vr(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dilations",a,e,t),o=s[1],u=s[2],l=n[1],p=n[2];return[xr(r("x",a,e,t),r("filter",a,e,t),[o,u],i,[l,p],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=(a,e,t)=>{switch(a.op){case"Fill":{const s=r("shape",a,e,t),i=r("dtype",a,e,t),n=r("value",a,e,t);return[Qr(s,n,i)]}case"LinSpace":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("num",a,e,t);return[li(s,i,n)]}case"Multinomial":{const s=r("logits",a,e,t),i=r("numSamples",a,e,t),n=r("seed",a,e,t);return[di(s,i,n)]}case"OneHot":{const s=r("indices",a,e,t),i=r("depth",a,e,t),n=r("onValue",a,e,t),o=r("offValue",a,e,t);return[Xr(s,i,n,o)]}case"Ones":return[Zr(r("shape",a,e,t),r("dtype",a,e,t))];case"OnesLike":return[Yr(r("x",a,e,t))];case"RandomUniform":return[Jr(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("dtype",a,e,t))];case"Range":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("step",a,e,t);return[Kr(s,i,n,r("dtype",a,e,t))]}case"TruncatedNormal":{const s=r("shape",a,e,t),i=r("mean",a,e,t),n=r("stdDev",a,e,t),o=r("seed",a,e,t);return[Gr(s,i,n,r("dtype",a,e,t),o)]}case"Zeros":return[ya(r("shape",a,e,t),r("dtype",a,e,t))];case"ZerosLike":return[Ur(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(a,e,t){const s=r("boxes",a,e,t),i=r("scores",a,e,t),n=r("maxOutputSize",a,e,t),o=r("iouThreshold",a,e,t),u=r("scoreThreshold",a,e,t),l=r("softNmsSigma",a,e,t);return{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}}const To=async(a,e,t)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=tt(a,e,t),p=await Ee.nonMaxSuppressionWithScoreAsync(s,i,n,o,u,l);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=tt(a,e,t),l=r("padToMaxOutputSize",a,e,t),p=await Ee.nonMaxSuppressionPaddedAsync(s,i,n,o,u,l);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=tt(a,e,t);return[await Ee.nonMaxSuppressionAsync(s,i,n,o,u)]}case"Where":{const s=Fe(r("condition",a,e,t),"bool"),i=[await gi(s)];return s.dispose(),i}case"ListDiff":return yi(r("x",a,e,t),r("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So=(a,e,t)=>{switch(a.op){case"TopKV2":{const s=r("x",a,e,t),i=r("k",a,e,t),n=r("sorted",a,e,t),o=Mr(s,i,n);return[o.values,o.indices]}case"Unique":{const s=r("x",a,e,t),i=Bt(s);return[i.values,i.indices]}case"UniqueV2":{const s=r("x",a,e,t),i=r("axis",a,e,t),n=Bt(s,i);return[n.values,n.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo=(a,e,t)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const s=r("default",a,e,t);return[se(a.name,e,t)||s];case"Placeholder":return[se(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=r("x",a,e,t);return[Ne(p)]}case"IdentityN":return r("x",a,e,t).map(p=>Ne(p));case"Snapshot":const i=r("x",a,e,t);return[Ne(i)];case"Shape":return[Ht(r("x",a,e,t).shape,"int32")];case"ShapeN":return r("x",a,e,t).map(p=>Ht(p.shape));case"Size":return[ve(r("x",a,e,t).size,"int32")];case"Rank":return[ve(r("x",a,e,t).rank,"int32")];case"NoOp":return[ve(1)];case"Print":const n=r("x",a,e,t),o=r("data",a,e,t),u=r("message",a,e,t),l=r("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,l));return[n];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _o{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ve(0),this.tensorMap=new Map,Oe(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),W(()=>{const i=Re(t),n=s.length,o=i.length;L(n===o,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${o} elements.`);for(let u=0;u<n;u++){const l=s[u],p=i[u];Oe(p),this.tensorMap.set(l,p)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return W(()=>{const i=[];for(let n=0;n<s.length;n++){const o=s[n],u=this.findWithDefault(o,t);i.push(u)}return je(i)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ko=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const i=r("keyDType",a,e,t),n=r("valueDType",a,e,t),o=new _o(i,n);return s.addHashTable(a.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("values",a,e,t);return[await s.getHashTableById(i.id).import(n,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("defaultValue",a,e,t);return[await s.getHashTableById(i.id).find(n,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=r("tableHandle",a,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=(a,e,t)=>{switch(a.op){case"ResizeBilinear":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Ee.resizeBilinear(s,[i[0],i[1]],n,o)]}case"ResizeNearestNeighbor":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Ee.resizeNearestNeighbor(s,[i[0],i[1]],n,o)]}case"CropAndResize":{const s=r("image",a,e,t),i=r("boxes",a,e,t),n=r("boxInd",a,e,t),o=r("cropSize",a,e,t),u=r("method",a,e,t),l=r("extrapolationValue",a,e,t);return[Ee.cropAndResize(s,i,n,o,u,l)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Io=(a,e,t)=>{switch(a.op){case"Equal":return[pn(r("a",a,e,t),r("b",a,e,t))];case"NotEqual":return[ln(r("a",a,e,t),r("b",a,e,t))];case"Greater":return[un(r("a",a,e,t),r("b",a,e,t))];case"GreaterEqual":return[on(r("a",a,e,t),r("b",a,e,t))];case"Less":return[nn(r("a",a,e,t),r("b",a,e,t))];case"LessEqual":return[rn(r("a",a,e,t),r("b",a,e,t))];case"LogicalAnd":return[sn(r("a",a,e,t),r("b",a,e,t))];case"LogicalNot":return[an(r("a",a,e,t))];case"LogicalOr":return[tn(r("a",a,e,t),r("b",a,e,t))];case"Select":case"SelectV2":return[en(r("condition",a,e,t),r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo=(a,e,t)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[dn(r("a",a,e,t),r("b",a,e,t),r("transposeA",a,e,t),r("transposeB",a,e,t))];case"Transpose":return[cn(r("x",a,e,t),r("perm",a,e,t))];case"_FusedMatMul":const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=r("numArgs",a,e,t),l=r("leakyreluAlpha",a,e,t);if(n){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,c]=r("args",a,e,t);return[mn({a:r("a",a,e,t),b:r("b",a,e,t),transposeA:r("transposeA",a,e,t),transposeB:r("transposeB",a,e,t),bias:p,activation:i,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ao=(a,e,t)=>{switch(a.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Wt(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"FusedBatchNormV3":return[Wt(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"LRN":return[fn(r("x",a,e,t),r("radius",a,e,t),r("bias",a,e,t),r("alpha",a,e,t),r("beta",a,e,t))];case"Softmax":return[yn(r("x",a,e,t))];case"LogSoftmax":return[hn(r("x",a,e,t))];case"SparseToDense":return[Na(r("sparseIndices",a,e,t),r("outputShape",a,e,t),r("sparseValues",a,e,t),r("defaultValue",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $o=(a,e,t)=>{switch(a.op){case"Max":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[kn(r("x",a,e,t),o,u)]}case"Mean":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[_n(r("x",a,e,t),o,u)]}case"Min":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[wn(r("x",a,e,t),o,u)]}case"Sum":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[Sn(r("x",a,e,t),o,u)]}case"All":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[Tn(r("x",a,e,t),o,u)]}case"Any":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[vn(r("x",a,e,t),o,u)]}case"ArgMax":{const o=r("axis",a,e,t);return[Nn(r("x",a,e,t),o)]}case"ArgMin":{const o=r("axis",a,e,t);return[bn(r("x",a,e,t),o)]}case"Prod":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[ha(r("x",a,e,t),o,u)]}case"Cumsum":{const o=r("axis",a,e,t),u=r("exclusive",a,e,t),l=r("reverse",a,e,t);return[gn(r("x",a,e,t),o,u,l)]}case"Bincount":const s=r("x",a,e,t),i=r("weights",a,e,t),n=r("size",a,e,t);return[ii(s,i,n)];case"DenseBincount":{const o=r("x",a,e,t),u=r("weights",a,e,t),l=r("size",a,e,t),p=r("binaryOutput",a,e,t);return[ui(o,u,l,p)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Do=(a,e,t)=>{switch(a.op){case"ConcatV2":case"Concat":{const s=r("n",a,e,t),i=r("axis",a,e,t);let n=r("tensors",a,e,t);return n=n.slice(0,s),[Nt(n,i)]}case"Gather":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[Ut(s,Fe(i,"int32"),0)]}case"GatherV2":{const s=r("axis",a,e,t),i=r("batchDims",a,e,t),n=r("x",a,e,t),o=r("indices",a,e,t);return[Ut(n,Fe(o,"int32"),s,i)]}case"Reverse":{const s=r("dims",a,e,t),i=[];for(let o=0;o<s.length;o++)s[o]&&i.push(o);const n=r("x",a,e,t);return[qt(n,i)]}case"ReverseV2":{const s=r("axis",a,e,t),i=r("x",a,e,t);return[qt(i,s)]}case"Slice":{const s=r("begin",a,e,t),i=r("size",a,e,t);return[vt(r("x",a,e,t),s,i)]}case"StridedSlice":{const s=r("begin",a,e,t),i=r("end",a,e,t),n=r("strides",a,e,t),o=r("beginMask",a,e,t),u=r("endMask",a,e,t),l=r("ellipsisMask",a,e,t),p=r("newAxisMask",a,e,t),c=r("shrinkAxisMask",a,e,t),h=r("x",a,e,t);return[En(h,s,i,n,o,u,l,p,c)]}case"Pack":return W(()=>{const s=r("axis",a,e,t),i=r("tensors",a,e,t),n=i[0].shape,o=st(i[0]).shape,u=i.map(l=>{const p=at(l.shape,n);if(!p&&!at(st(l).shape,o))throw new Error("the input tensors shape does not match");return p?l:te(l,n)});return[je(u,s)]});case"Unpack":{const s=r("axis",a,e,t),i=r("tensor",a,e,t);return Re(i,s)}case"Tile":{const s=r("reps",a,e,t);return[In(r("x",a,e,t),s)]}case"Split":case"SplitV":{const s=r("axis",a,e,t),i=r("numOrSizeSplits",a,e,t),n=r("x",a,e,t);return On(n,i,s)}case"ScatterNd":{const s=r("indices",a,e,t),i=r("values",a,e,t),n=r("shape",a,e,t);return[Ni(s,i,n)]}case"GatherNd":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[wi(s,i)]}case"SparseToDense":{const s=r("sparseIndices",a,e,t),i=r("outputShape",a,e,t),n=r("sparseValues",a,e,t),o=r("defaultValue",a,e,t);return[Na(s,n,i,n.dtype===o.dtype?o:Fe(o,n.dtype))]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Po=(a,e,t)=>{switch(a.op){case"FFT":return[Pn(r("x",a,e,t))];case"IFFT":return[Dn(r("x",a,e,t))];case"RFFT":return[$n(r("x",a,e,t))];case"IRFFT":return[An(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zo=(a,e,t)=>{switch(a.op){case"Cast":return[Fe(r("x",a,e,t),r("dtype",a,e,t))];case"ExpandDims":{const s=r("axis",a,e,t);return[jn(r("x",a,e,t),s)]}case"Squeeze":{const s=r("axis",a,e,t);return[st(r("x",a,e,t),s)]}case"Reshape":return[te(r("x",a,e,t),r("shape",a,e,t))];case"MirrorPad":return[Fn(r("x",a,e,t),r("padding",a,e,t),r("mode",a,e,t))];case"PadV2":case"Pad":return[Ln(r("x",a,e,t),r("padding",a,e,t),r("constantValue",a,e,t))];case"SpaceToBatchND":{const s=r("blockShape",a,e,t),i=r("paddings",a,e,t);return[Vn(r("x",a,e,t),s,i)]}case"BatchToSpaceND":{const s=r("blockShape",a,e,t),i=r("crops",a,e,t);return[xn(r("x",a,e,t),s,i)]}case"DepthToSpace":{const s=r("blockSize",a,e,t),i=r("dataFormat",a,e,t).toUpperCase();return[Cn(r("x",a,e,t),s,i)]}case"BroadcastTo":return[zn(r("x",a,e,t),r("shape",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ea(a,e,t,s){const i=((n,o,u)=>{switch(n.category){case"arithmetic":return W(()=>po(n,o,u));case"basic_math":return W(()=>mo(n,o,u));case"control":return bo(n,o,u);case"convolution":return W(()=>No(n,o,u));case"creation":return W(()=>vo(n,o,u));case"dynamic":return To(n,o,u);case"evaluation":return W(()=>So(n,o,u));case"image":return W(()=>Oo(n,o,u));case"graph":return W(()=>wo(n,o,u));case"logical":return W(()=>Io(n,o,u));case"matrices":return W(()=>Eo(n,o,u));case"normalization":return W(()=>Ao(n,o,u));case"reduction":return W(()=>$o(n,o,u));case"slice_join":return W(()=>Do(n,o,u));case"spectral":return W(()=>Po(n,o,u));case"transformation":return W(()=>zo(n,o,u));case"hash_table":return ko(n,o,u,s);case"custom":const l=va(n.op);if(l&&l.customExecutor)return l.customExecutor(new lo(n,o,u));throw TypeError(`Custom op ${n.op} is not registered.`);default:throw TypeError(`Unknown op '${n.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return rt(i)?i.then(n=>[].concat(n)):[].concat(i)}class ta{constructor(e={},t={},s={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(a,e,t,s){const i=new Set,n=[];let o=null,u=null;const l=new Set,p=Object.keys(a).map(d=>ne(d)[0]);let c=[];s!=null&&(c=s.map(d=>ne(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((wa(d)||Fo(d)||jo(d))&&o==null&&(o=d,u=o.children.map(f=>f.name).filter(f=>i.has(f))),i.add(d.name),t[d.name]==null&&p.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){n.push(d.name);continue}d.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),h.push(f))})}}return{inputs:a,outputs:e,usedNodes:i,missingInputs:n,dynamicNode:o,syncInputs:u}}function Co(a,e,t){const{usedNodes:s,inputs:i}=t,n=[],o=Object.keys(i).map(c=>ne(c)[0]).map(c=>a.nodes[c]),u=a.initNodes;o.forEach(c=>{s.has(c.name)&&n.push(c)}),a.weights.forEach(c=>{s.has(c.name)&&n.push(c)}),u!=null&&u.forEach(c=>{s.has(c.name)&&n.push(c)});const l=new Set,p=[];for(;n.length>0;){const c=n.pop();l.add(c.name),e[c.name]||p.push(c),c.children.forEach(h=>{!l.has(h.name)&&s.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&n.push(h)})}return p}const xo=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Vo=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Lo=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function wa(a){return xo.indexOf(a.op)>=0}function Fo(a){return Vo.indexOf(a.op)>=0}function jo(a){return Lo.indexOf(a.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ke{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Ke(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(n=>n.name).sort(),i=t.map(n=>n.name).sort();return s.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const s=aa(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:n,syncInputs:o}=s;if(n!=null)throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const u=t.map(p=>p.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return Co(this.graph,this.weightMap,s)}execute(e,t){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(h=>this.graph.nodes[ne(h)[0]]),n=t.map(h=>ne(h)[0]);let o=n.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(i,o);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,o),this.compiledMap.set(u,l));const p={},c={};return W(()=>{const h=new ta(this.weightMap,p,c,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[v,j]=ne(N),J=[];J[j]=e[N],d[v]=J});const f=this.getFrozenTensorIds(d),b={};for(let N=0;N<l.length;N++){const v=l[N];if(!d[v.name]){const j=ea(v,d,h,this._resourceManager);if(rt(j))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);d[v.name]=j,this.checkTensorForDisposal(v.name,v,d,h,f,n,b)}}return this.parent==null&&h.dispose(f),t.map(N=>se(N,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,n,o,u){t.category==="control"||o.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(u[l.id]=(u[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const p=Ii(l.name,s,i);p!=null&&p.forEach(c=>{if(c&&!n.has(c.id)){const h=u[c.id];h===1?(c.dispose(),delete u[c.id]):h!=null&&u[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,s=!1,i={},n={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const o=new ta(this.weightMap,i,n,this.functionExecutorMap),u=await this.executeWithControlFlow(e,o,t,s),l=t.map(d=>se(d,u,o)),p=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...p,...c,...this.weightIds]);return Object.keys(u).forEach(d=>{u[d].forEach(b=>{b&&!b.isDisposed&&!h.has(b.id)&&b.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,s){const i=e.reduce((n,o,u)=>(n[this.inputs[u].name]=o,n),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const n=Object.keys(e),o=n.map(C=>this.graph.nodes[ne(C)[0]]),u=s.map(C=>ne(C)[0]);let l=u.map(C=>this.graph.nodes[C]);l.length===0&&(l=this._outputs);const{usedNodes:p,missingInputs:c,dynamicNode:h,syncInputs:d}=aa(e,l,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[Te,re]=ne(C),V=[];V[re]=e[C],b[Te]=V});const N={},v=this.getFrozenTensorIds(b),j={};for(;f.length>0;){const C=this.processStack(o,f,t,b,j,v,u,N,p);await Promise.all(C)}h==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const J=l.filter(C=>!wa(C)&&!se(C.name,b,t)).map(C=>C.name);if(J.length>0){let C="";throw h!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${J}] from the provided inputs [${n}]. Consider providing the following inputs: [${c}]. ${C}`)}return b}processStack(e,t,s,i,n,o,u,l,p){const c=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&r("isConstant",h.node,i,s)&&([d]=be(h.node.name,s)),i[h.node.name]==null){const f=ea(h.node,i,s,this._resourceManager);d||([d]=be(h.node.name,s));const b=s.currentContext;rt(f)?c.push(f.then(N=>(i[d]=N,s.currentContext=b,this.checkTensorForDisposal(d,h.node,i,s,o,u,l),this.processChildNodes(h.node,t,s,i,n,p),N))):(i[d]=f,this.checkTensorForDisposal(d,h.node,i,s,o,u,l),this.processChildNodes(h.node,t,s,i,n,p))}else this.processChildNodes(h.node,t,s,i,n,p)}return c}processChildNodes(e,t,s,i,n,o){e.children.forEach(u=>{const[l]=be(u.name,s);n[l]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(p=>!!se(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})):u.inputNames.every(p=>!!se(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=ne(t),n=this.graph.nodes[i];if(n.attrParams.shape&&n.attrParams.shape.value){const o=n.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((l,p)=>o[p]===-1||o[p]===l);L(u,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&L(s.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const t={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const i=this._signature.inputs[s];t[i.name]=e[s]}else t[s]=e[s];return t}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=ne(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[s]=ne(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Ro{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo="?tfjs-format=file",Ho="model.json";class Wo{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new Ro}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Yt(e,this.loadOptions);else{const t=Rn(e,this.loadOptions);if(t.length===0)t.push(Yt(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=Bn(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ke(Zt.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const n=Zt.Instance.transformGraph(e.modelInitializer);this.initializer=new Ke(n),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=Hn(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof fa)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,s,i)=>(t[s]=e[i],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function qo(a,e={}){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&a.load==null&&(a.endsWith("/")||(a=a+"/"),a=`${a}${Ho}${Bo}`);const t=new Wo(a,e);return await t.load(),t}/**
 * @license
 * Copyright 2019 Victor Dibia.
 * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.
 * Licensed under the MIT License (the "License");
 * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
 * =============================================================================
 */const Uo="https://cdn.jsdelivr.net/npm/handtrackjs@latest/models/webmodel/",Go={1:"open",2:"closed",3:"pinch",4:"point",5:"face",6:"pointtip",7:"pinchtip"},Ko={flipHorizontal:!1,outputStride:16,imageScaleFactor:1,maxNumBoxes:20,iouThreshold:.2,scoreThreshold:.6,modelType:"ssd320fpnlite",modelSize:"small",bboxLineWidth:"2",fontSize:17,basePath:Uo,labelMap:Go,renderThresholds:null},Jo={large:"base",medium:"fp16",small:"int8"},sa={open:"#374151",closed:"#B91C1C",pinch:"#F59E0B",point:"#10B981",face:"#3B82F6",pointtip:"#6366F1",pinchtip:"#EC4899"},ra={ssd320fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],ssd640fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],centernet512fpn:["Identity_4:0","Identity:0","Identity_2:0"]};async function Yo(a){let e=Object.assign({},Ko,a);const t=new Qo(e);return await t.load(),t}function Zo(a){return new Promise(function(e,t){a||e({status:!1,msg:"please provide a valid video element"}),a.width=a.width||640,a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height="20px",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(s=>{window.localStream=s,a.srcObject=s,a.onloadedmetadata=()=>{a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height=parseInt(a.style.width)*(a.videoHeight/a.videoWidth).toFixed(2)+"px",a.play(),e({status:!0,msg:"webcam successfully initiated."})}}).catch(function(s){e({status:!1,msg:s})})})}async function Xo(){if(window.localStream)window.localStream.getTracks().forEach(a=>(a.stop(),!0));else return!1}class Qo{constructor(e){this.modelPath=e.basePath+e.modelType+"/"+(Jo[e.modelSize]||"base")+"/model.json ",this.modelParams=e}async load(){this.fps=0,this.model=await qo(this.modelPath);const e=ya([1,300,300,3],"int32"),t=await this.model.executeAsync(e,ra[this.modelParams.modelType]);t.map(async s=>await s.data()),t.map(async s=>s.dispose()),et(e)}async detect(e){let t=Date.now();const[s,i]=Mo(e),n=na(this.modelParams.imageScaleFactor,s,this.modelParams.outputStride),o=na(this.modelParams.imageScaleFactor,i,this.modelParams.outputStride),u=W(()=>{const p=ai(e);return this.modelParams.flipHorizontal?p.reverse(1).resizeBilinear([n,o]).expandDims(0).toInt():p.resizeBilinear([n,o]).expandDims(0).toInt()}),l=this;return this.model.executeAsync(u,ra[this.modelParams.modelType]).then(function(p){u.dispose();let c=[];if(l.modelParams.modelType==="centernet512fpn"){const d=p[0].dataSync(),f=p[1].arraySync(),b=p[2].dataSync();et(p),c=l.buildDetectObjectsCenternet(i,s,f[0],d,b),console.log(c)}else{const d=p[0].dataSync(),f=p[1].dataSync();et(p);const[b,N]=eu(d,p[0].shape[1],p[0].shape[2]),v=Wn();Gt("cpu");const j=W(()=>{const C=qn(f,[p[1].shape[1],p[1].shape[3]]);return Ee.nonMaxSuppression(C,b,l.modelParams.maxNumBoxes,l.modelParams.iouThreshold,l.modelParams.scoreThreshold)}),J=j.dataSync();j.dispose(),Gt(v),c=l.buildDetectedObjects(i,s,f,b,J,N)}let h=Date.now();return l.fps=Math.round(1e3/(h-t)),c})}buildDetectedObjects(e,t,s,i,n,o){const u=n.length,l=[];for(let p=0;p<u;p++){const c=[];for(let v=0;v<4;v++)c[v]=s[n[p]*4+v];const h=c[0]*t,d=c[1]*e,f=c[2]*t,b=c[3]*e;c[0]=d,c[1]=h,c[2]=b-d,c[3]=f-h;const N=Math.round(o[n[p]])+1;l.push({bbox:c,class:N,label:this.modelParams.labelMap[N],score:i[n[p]].toFixed(2)})}return l}buildDetectObjectsCenternet(e,t,s,i,n){const o=[];for(let u=0;u<i.length;u++){const l=s[u],p=l[0]*t,c=l[1]*e,h=l[2]*t,d=l[3]*e;l[0]=c,l[1]=p,l[2]=d-c,l[3]=h-p;const f=Math.round(n[u])+1;o.push({bbox:l,class:f,label:this.modelParams.labelMap[f],score:i[u].toFixed(2)})}return o.slice(0,10)}getFPS(){return this.fps}setModelParameters(e){this.modelParams=Object.assign({},this.modelParams,e)}getModelParameters(){return this.modelParams}roundRect(e,t,s,i,n,o,u,l){if(typeof l>"u"&&(l=!0),typeof o>"u"&&(o=5),typeof o=="number")o={tl:o,tr:o,br:o,bl:o};else{var p={tl:0,tr:0,br:0,bl:0};for(var c in p)o[c]=o[c]||p[c]}e.beginPath(),e.moveTo(t+o.tl,s),e.lineTo(t+i-o.tr,s),e.quadraticCurveTo(t+i,s,t+i,s+o.tr),e.lineTo(t+i,s+n-o.br),e.quadraticCurveTo(t+i,s+n,t+i-o.br,s+n),e.lineTo(t+o.bl,s+n),e.quadraticCurveTo(t,s+n,t,s+n-o.bl),e.lineTo(t,s+o.tl),e.quadraticCurveTo(t,s,t+o.tl,s),e.closePath(),u&&e.fill(),l&&e.stroke()}renderPredictions(e,t,s,i){s.clearRect(0,0,t.width,t.height),t.width=i.width,t.height=i.height,t.style.height=parseInt(t.style.width)*(i.height/i.width).toFixed(2)+"px",s.save(),this.modelParams.flipHorizontal&&(s.scale(-1,1),s.translate(-i.width,0)),s.drawImage(i,0,0,i.width,i.height),s.restore(),s.font="bold "+this.modelParams.fontSize+"px Arial";const n=this.modelParams.renderThresholds;for(let o=0;o<e.length;o++){const u=e[o];(!n||u.score>n[u.label])&&(s.beginPath(),s.fillStyle="rgba(255, 255, 255, 0.6)",s.fillRect(u.bbox[0]+1,u.bbox[1]+1,u.bbox[2]-1,this.modelParams.fontSize*1.5),s.lineWidth=this.modelParams.bboxLineWidth,this.roundRect(s,u.bbox[0],u.bbox[1],u.bbox[2],u.bbox[3],5,!1,!0),s.strokeStyle=sa[u.label],s.fillStyle=sa[u.label],s.stroke(),s.beginPath(),s.arc(u.bbox[0]+u.bbox[2]/2,u.bbox[1]+u.bbox[3]/2,2,0,2*Math.PI),s.fill(),s.stroke(),s.fillText(u.score+" | "+u.label,u.bbox[0]+5,u.bbox[1]+this.modelParams.fontSize*1.1))}s.fillStyle="rgba(255, 255, 255, 0.6)",this.roundRect(s,10,10,this.modelParams.fontSize*4.6,this.modelParams.fontSize+8,5,!0,!1),s.strokeStyle="#374151",s.fillStyle="#374151",s.font="bold "+this.modelParams.fontSize+"px Arial",s.fillText("FPS: "+this.fps,18,this.modelParams.fontSize+12)}dispose(){this.model&&this.model.dispose()}}function na(a,e,t){const s=e*a-1;return s-s%t+1}function Mo(a){return a instanceof fa?[a.shape[0],a.shape[1]]:[a.height,a.width]}function eu(a,e,t){const s=[],i=[];for(let n=0;n<e;n++){let o=Number.MIN_VALUE,u=-1;for(let l=0;l<t;l++)a[n*t+l]>o&&(o=a[n*t+l],u=l);s[n]=o,i[n]=u}return[s,i]}const tu={class:"mt-2"},au={class:"mb-1 mt-2"},su={class:"text-medium-emphasis"},ru={class:"mt-2"},nu={class:"text-h4 text-medium-emphasis mt-4"},iu={key:0,class:"mt-6"},ou={key:0,style:{"font-style":"italic","font-size":"1.2em"},class:"mt-3"},uu=["id"],lu={key:0},pu={key:0,class:"mt-2 mb-4"},mu=["innerHTML"],cu=["innerHTML"],du={key:1,class:"mt-6"},hu={key:0,class:"mb-4"},yu={key:1},fu={style:{"font-size":"0.9em"}},gu={class:"mt-4"},bu={class:"text-center",style:{"margin-top":"40px"}},Nu={key:0},vu={class:"text-center mt-2",id:"ratingPart"},Tu={class:"text-medium-emphasis mt-6"},Su={key:2,class:"custom-bottom-sheet no-print"},wu={class:"sheet-content",style:{"background-color":"rgb(226, 226, 226)"}},_u={key:0,class:"mb-2"},ku={class:"my-1"},Ou={key:1,class:"mb-2"},Iu={class:"my-1"},Eu={key:2,class:"sheet-ingredients"},Au={key:0},$u={key:1},Du={key:0,class:"mb-2"},Pu={style:{"font-size":"1.7em","border-radius":"6px","background-color":"#ffffff",color:"#3d3d3d"},class:"px-2"},zu={key:0},Cu={key:1},xu={style:{"background-color":"rgb(203, 203, 204)",display:"flex"}},Vu={class:"ml-2",style:{width:"100px","flex-shrink":"0"}},Lu={class:"mx-2",style:{flex:"1"}},Fu={class:"mr-2",style:{width:"100px","flex-shrink":"0"}},ia="*",ju={__name:"MealMaker",setup(a){xt.extend(Za);const e=ua(),t=la(),{authInfo:s,githubMode:i,lanAddress:n}=Xa(t),o=pa(),l=ft().query.id,p=D(null),c=D(null),h=D(2),d=D([]),f=D(null),b=D(!1),N=D(!1),v=D(null),j=D(null),J=D([]),C=D(!0),Te=D(!0),re=D(!0),V=D([]),le=D(!1),U=D(null),Y=D(null),X=D(!1),Ae=D([]),Ie=D([]),M=D(-1),xe=D(-1),wt=D([]),Ve=D([]),Be=D(!1),$e=D(!1),Je=D(60);gt(async()=>{p.value=null,c.value=null;let y=await t.getAuthInfo();if(await He(),await pe(!0),p.value.planned&&!p.value.cooked&&!i.value){let O=y.calendarPlan??{};const _=new Date,A=_.getFullYear(),$=String(_.getMonth()+1).padStart(2,"0"),k=String(_.getDate()).padStart(2,"0");O[`${A}-${$}-${k}`]&&(O[`${A}-${$}-${k}`].type==="RECIPE"&&O[`${A}-${$}-${k}`].recipeId&&O[`${A}-${$}-${k}`].recipeId!==p.value.id||O[`${A}-${$}-${k}`].type==="SCHEDULED"||O[`${A}-${$}-${k}`].type==="OTHER")?Be.value=!0:($e.value=!0,setTimeout(async()=>{for(let x=0;x<60&&$e.value!==!1;x++){if(Je.value--,Je.value===0){$e.value=!1,await Ye();break}await new Promise(Z=>setTimeout(Z,1e3))}},100))}const m=localStorage.getItem("timers-"+l);if(m)try{const O=JSON.parse(m);O.forEach(_=>{_.isPaused=!0}),d.value=O.map(_=>({..._,timeoutId:null}))}catch(O){console.error("Timer konnte nicht geladen werden:",O)}}),Qa(()=>{d.value.forEach(y=>clearTimeout(y.timeoutId)),clearTimeout(f.value)}),Ma(d,y=>{const m=y.map(({timeoutId:O,..._})=>_);localStorage.setItem("timers-"+l,JSON.stringify(m))},{deep:!0}),window.addEventListener("message",y=>{var O;const m=y.data;if(!(!m||typeof m!="object")&&(m.type==="speech-commands:ready"&&console.log(`iFrame bereit (${((O=m.vocab)==null?void 0:O.length)||0} WÃ¶rter)`),m.type==="speech-commands:result")){const _=m.scores.find(k=>k.label==="go"),A=m.scores.find(k=>k.label==="one"),$=m.scores.find(k=>k.label==="eight");_&&_.score>=.7&&(X.value=!0,U.value="HEARING",Y.value&&clearTimeout(Y.value),Y.value=setTimeout(()=>{X.value=!1,U.value="LISTENING"},2e3)),(A&&A.score>=.8||$&&$.score>=.8)&&X.value&&(X.value=!1,U.value="CLOSED",Vt.reduceExecutions("speech-commands",()=>{M.value++,pe(),Y.value=setTimeout(()=>{U.value="LISTENING"},1e3)},1e3))}});async function _a(){await fe.planRecipe(s.value.userId,l),await He()}async function Ye(){const y={cooked:!0};await fe.updateRecipe(s.value.userId,l,y),fe.uploadRecipeToGithub(s.value.userId,null);let m=s.value.calendarPlan;m||(m={});const O=new Date,_=O.getFullYear(),A=String(O.getMonth()+1).padStart(2,"0"),$=String(O.getDate()).padStart(2,"0");m[`${_}-${A}-${$}`]={type:"RECIPE",recipeId:l,recipeTitle:p.value.title,cooked:!0},await ns.saveCalendarPlan(s.value.userId,m),Be.value=!1,$e.value=!1}const ka=Me(()=>!V||V.value.length===0?0:V.value.filter(y=>!y.ingredient&&y.duration).reduce((y,m)=>y+m.duration,0)),_t=Me(()=>!V||V.value.length===0?[]:V.value.filter(y=>!!y.ingredient)),Oa=Me(()=>!V||V.value.length===0?[]:V.value.filter(y=>!y.ingredient));function Ia(){const y=[];p.value.ingredients.forEach(m=>{if(m.preparationRequired){let O=m.preparationLongText;const _=c.value.find(A=>m.name===A.name);if(_){let A="";A=_.amount?_.amount+(_.unit?" "+_.unit:"")+" ":"",O?O=O.replace(m.basicName,A+" "+m.basicName):O=A+" "+m.basicName+" vorbereiten."}y.push({name:O,ingredient:!0})}}),p.value.sections.forEach(m=>{m.ingredientsPreparations&&m.ingredientsPreparations.length>0&&m.ingredientsPreparations.forEach(O=>{let _=[],A=O.instruction;for(let $=0;$<m.usedIngredients.length;$++){let k=m.usedIngredients[$];const x=c.value.find(ce=>ce.name===k.ingredientNameList);let Z="";x&&!_.includes(x.name)&&(Z=x.amount?x.amount+(x.unit?" "+x.unit:"")+" ":"",_.push(x.name),A=A.replace(k.ingredientNameText,Z+" "+k.ingredientNameText))}y.push({name:A,originalName:O.instruction,sectionIndex:m.index-1,duration:O.duration})})}),V.value=y}function Ea(){M.value=-1,C.value=!0,pe()}function Aa(y){return i.value?"https://mmhhhh.de/data/home/recipes/"+y.id+"/image.jpg":n.value+"api/"+s.value.userId+"/recipes/"+y.id+"/image"}function kt(){window.close(),setTimeout(()=>{document.title="Cookio - Rezeptmanager",o.push("/recipes")},500)}async function $a(){const y={preparations:[]};await fe.updateRecipe(s.value.userId,l,y),await He(),await pe(!0)}function Da(y){$t(y),pe(!0)}async function Pa(y){const m={rating:y};await fe.updateRecipe(s.value.userId,l,m),await pe()}async function Ot(){if(!i.value){const y={preparations:V.value};await fe.updateRecipe(s.value.userId,l,y),await pe()}}function za(y){setTimeout(()=>{Ve.value.splice(y,1)},500)}function It(y){y&&!y.target.closest(".stopwatch-button")&&(M.value++,pe())}function Ca(y){Ve.value.push({taskNr:M.value,sectionNr:xe.value,description:Ie.value[M.value+1],checked:!1}),It(y)}async function He(){p.value=await fe.getRecipe(s.value.userId,l),p.value.ingredients=(await fe.getRecipeIngredients(s.value.userId,l)).data,p.value.sections=(await fe.getRecipeSections(s.value.userId,l)).data,pe(!0)}async function pe(y=!1){let m=JSON.parse(JSON.stringify(p.value.sections));$t(),y&&(p.value.preparations&&p.value.preparations.length>0?V.value=p.value.preparations:Ia()),Ae.value=[],Ie.value=[];let O=-1;if(d.value)for(let k=d.value.length-1;k>=0;k--)(d.value[k].remainingSeconds===0||!d.value[k].timerStarted)&&(d.value=d.value.filter(x=>x.id!==d.value[k].id||x.id===d.value[k].id&&d.value[k].timerStarted));const _=[];let A=null,$=0;for(let k=0;k<m.length;k++){let x=m[k],Z=x.description,ce=[],me=qa(Z);if($=O+me.length,me.forEach((q,R)=>{O++,Ae.value.push(q);let E=q;const de=V.value.find(H=>H.checked&&k===H.sectionIndex&&H.originalName===q);if(x.usedIngredients.forEach(H=>{const G=c.value.find(we=>we.name===H.ingredientNameList);let ee="";G&&!_.includes(G.name)&&(ee=G.amount?G.amount+(G.unit?" "+G.unit:"")+" ":"",E.includes(H.ingredientNameText)&&_.push(G.name)),E=E.replace(H.ingredientNameText,"<b>"+ee+H.ingredientNameText+"</b>")}),Ie.value.push(E),M.value>$||M.value>=O)E='<span style="color: #9a9a9a;">'+E+" </span>";else if(M.value+1===O){if(de)E='<span style="color: #9a9a9a;">'+E+" </span>",M.value++;else if(xe.value=k,e.smAndDown.value?E='<span style="background-color: #bfe7d2; font-size: 1.4em; box-decoration-break: clone;-webkit-box-decoration-break: clone;" class="pa-2">'+E+" </span> ":E='â–¶&nbsp;<span style="background-color: #bfe7d2; padding-top: 4px; padding-bottom: 4px">'+E+" </span> ",x.timer&&x.timer.length>0)for(let H=0;H<x.timer.length;H++)q.includes(x.timer[H].descriptionText)&&d.value.push({id:k+"-"+H,title:x.timer[H].title,remainingSeconds:x.timer[H].duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:x.timer[H].descriptionTextAfter})}ce.push(E)}),Z=ce.join(" "),M.value+1>$&&m.length>k+1&&(A=k+1),x.timer&&x.timer.length>0){let q="",R=Z;for(let E=0;E<x.timer.length;E++){const H=x.timer[E].descriptionText,G=R.indexOf(H);if(G===-1)continue;q+=R.slice(0,G);const ee=`<span class="pa-1 stopwatch-button" style="cursor: pointer; background-color: rgba(187,187,187,0.66); border: rgba(41,56,80,0.49) solid 3px; border-radius: 20px; color: #545454; font-size: 0.9em" data-id="${E}" data-sectionid="${k}"> â± ${H}</span>`;q+=ee,R=R.slice(G+H.length)}q+=R,Z=q}N.value||x.ingredientsPreparations.forEach(q=>{V.value.find(E=>E.checked&&k===E.sectionIndex&&E.originalName===q.instruction)&&(Z=Z.replace(q.instruction,'<span style="text-decoration-line: line-through;text-decoration-style: solid;text-decoration-thickness: 2px;text-underline-offset: 4px;">'+q.instruction+"</span>"))}),x.description=Z}M.value>$-1&&(C.value=!1),wt.value=m,re.value||setTimeout(()=>{document.getElementById("section-"+A).scrollIntoView({behavior:"smooth",block:"start"})},200),re.value=!1,document.title=p.value.title+" - Cookio"}function xa(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"start"},ia),le.value=!0,U.value="LISTENING"}function Va(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"stop"},ia),le.value=!1,U.value=null}function Et(y){v.value(y)}function At(){N.value=!N.value,C.value=!N.value,Te.value=!N.value,pe()}function $t(y){y&&(h.value=y);let m=p.value.portions?p.value.portions:2;c.value=[],p.value.ingredients.forEach(O=>{c.value.push({name:O.name,unit:O.unit,amount:Math.ceil(O.amount/m*h.value)})})}function La(y){const m=y.target.closest(".stopwatch-button");if(m){const O=m.dataset.id,_=m.dataset.sectionid,A=parseInt(O,10),$=parseInt(_,10),k=p.value.sections[$].timer[A];d.value.push({id:$+"-"+A,title:k.title,remainingSeconds:k.duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:k.descriptionTextAfter})}}const Fa=y=>{const m=xt.duration(y*1e3),O=String(m.minutes()).padStart(2,"0"),_=String(m.seconds()).padStart(2,"0");return`${O}:${_}`};function ja(y){d.value=d.value.filter(m=>m.id!==y)}const Ze=y=>{y.isPaused||y.remainingSeconds<=0||d.value.find(m=>m.id===y.id)&&(y.remainingSeconds--,y.remainingSeconds<=0&&(J.value.push(y),j.value(J.value).then(()=>{J.value=[],d.value=d.value.filter(m=>m.remainingSeconds>0)})),y.remainingSeconds>0?y.timeoutId=setTimeout(()=>Ze(y),1e3):y.timeoutId=null)},Ra=y=>{clearTimeout(y.timeoutId),y.timerStarted=!0,y.isPaused=!1,y.timeoutId=setTimeout(()=>Ze(y),1e3)},Ba=y=>{y.isPaused=!y.isPaused,!y.isPaused&&y.remainingSeconds>0&&(y.timeoutId=setTimeout(()=>Ze(y),1e3))},Ha=y=>{y.remainingSeconds=y.remainingSeconds+60},Wa=y=>{const m=y.remainingSeconds-60;y.remainingSeconds=Math.max(m,0)};function qa(y,m=[]){const O=["ca.","etc.","ggf.","bspw.","bzw.","vgl.","Dr.","Prof.","Nr.","Stk.","Abs.","Art.","Sek.","Std.","Min.","z. B.","u. a.","i. d. R.","z. T.","sog."],_=E=>E.toLowerCase().replace(/[.\s]/g,""),A=new Set([...O,...m].map(_)),$=E=>E>="0"&&E<="9",k=E=>/\s/.test(E),x=E=>/[)"'\]\}Â»â€]/.test(E),Z=y.length,ce=[];let me="",q=0;function R(E){const de=Math.max(0,E-15),H=_(y.slice(de,E));for(const G of A)if(H.endsWith(G))return!0;if(y[E]==="."){let G=E+1;for(;G<Z&&k(y[G]);)G++;if(G+1<Z&&/[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼]/.test(y[G])&&y[G+1]===".")return!0}return!1}for(;q<Z;){const E=y[q];if(me+=E,E==="."||E==="!"||E==="?"){const de=y[q-1]||"",H=y[q+1]||"";if(!(E==="."&&$(de)&&$(H))&&!R(q)){let ee=q+1;for(;ee<Z&&(x(y[ee])||y[ee]==="*");)me+=y[ee],ee++;const we=me.trim();for(we&&ce.push(we),me="";ee<Z&&k(y[ee]);)ee++;q=ee;continue}}q++}return me.trim()&&ce.push(me.trim()),ce}const De=D(null),Xe=es(null),Se=D(!1),Ua={flipHorizontal:!0,maxNumBoxes:2,scoreThreshold:.6,iouThreshold:.5};async function Ga(){if(!await Zo(De.value))throw new Error("Kamerazugriff verweigert.");await new Promise(m=>{if(De.value.readyState>=2)return m();De.value.onloadeddata=()=>m()})}async function Ka(){Xe.value=await Yo(Ua)}async function Dt(){if(!Se.value)return;const y=await Xe.value.detect(De.value);y.length>0&&(y.filter(m=>m.label==="open"&&m.score>.8).length>0&&(X.value=!0,U.value="OPEN",Y.value&&clearTimeout(Y.value),Y.value=setTimeout(()=>{X.value=!1,U.value="LISTENING"},2e3)),y.filter(m=>m.label==="closed"&&m.score>.8).length>0&&X.value&&(X.value=!1,U.value="CLOSED",Vt.reduceExecutions("recognition-pinch",()=>{M.value++,pe(),Y.value=setTimeout(()=>{U.value="LISTENING"},1e3)},1e3),console.log("preds",y))),await new Promise(m=>setTimeout(m,200)),Se.value&&Dt()}async function Ja(){if(!Se.value){U.value="LISTENING";try{await Ga(),Xe.value||await Ka(),Se.value=!0,Dt()}catch(y){console.error(y)}}}function Pt(){U.value=null,Se.value&&(Se.value=!1,Xo(De.value))}return ts(()=>{Pt()}),(y,m)=>{const O=B("v-app-bar-nav-icon"),_=B("v-icon"),A=B("v-list-item-title"),$=B("v-list-item"),k=B("v-divider"),x=B("v-chip"),Z=B("v-list"),ce=B("v-menu"),me=B("v-app-bar"),q=B("v-alert"),R=B("v-btn"),E=B("v-img"),de=B("v-checkbox"),H=B("v-card-text"),G=B("v-card"),ee=B("v-rating"),we=B("v-container"),Pe=B("v-col"),Qe=B("v-row"),Ya=B("v-table");return w(),z("div",null,[g(me,{collapse:"",elevation:0,color:"#6969695A",class:"no-print"},{prepend:S(()=>[g(ce,null,{activator:S(({props:T})=>[g(O,as(ss(T)),null,16),I("div",null,[U.value==="OPEN"?(w(),Q(_,{key:0,icon:"mdi-hand-back-left-outline",size:"30"})):P("",!0),U.value==="HEARING"?(w(),Q(_,{key:1,icon:"mdi-ear-hearing",size:"30"})):P("",!0),U.value==="CLOSED"?(w(),Q(_,{key:2,icon:"mdi-check-decagram-outline",size:"30"})):P("",!0),U.value==="LISTENING"?(w(),Q(_,{key:3,icon:"mdi-record-rec",size:"30"})):P("",!0)])]),default:S(()=>[g(Z,{class:"mt-2"},{default:S(()=>[g($,{onClick:At},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-knife",size:"20"}),F(" Schnibbelmodus "+ae(N.value?"beenden":""),1)]),_:1})]),_:1}),le.value?P("",!0):(w(),Q($,{key:0,onClick:m[0]||(m[0]=T=>xa())},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-microphone-message",size:"20"}),m[13]||(m[13]=F(" Sprachsteuerung aktivieren",-1))]),_:1})]),_:1})),le.value?(w(),Q($,{key:1,onClick:m[1]||(m[1]=T=>Va())},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-microphone-message-off",size:"20"}),m[14]||(m[14]=F(" Sprachsteuerung beenden",-1))]),_:1})]),_:1})):P("",!0),Se.value?P("",!0):(w(),Q($,{key:2,onClick:m[2]||(m[2]=T=>Ja())},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-hand-okay",size:"20"}),m[15]||(m[15]=F(" Gestensteuerung aktivieren",-1))]),_:1})]),_:1})),Se.value?(w(),Q($,{key:3,onClick:m[3]||(m[3]=T=>Pt())},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-hand-okay",size:"20"}),m[16]||(m[16]=F(" Gestensteuerung beenden",-1))]),_:1})]),_:1})):P("",!0),g($,{onClick:Ea,disabled:M.value===-1},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-backup-restore",size:"20"}),m[17]||(m[17]=F(" Fortschritt zurÃ¼cksetzen",-1))]),_:1})]),_:1},8,["disabled"]),g(k),he(i)?P("",!0):(w(),Q($,{key:4,onClick:m[4]||(m[4]=T=>_a(p.value)),disabled:p.value.planned},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-bowl-mix",size:"20"}),m[18]||(m[18]=F(" Einplanen",-1))]),_:1})]),_:1},8,["disabled"])),g($,{onClick:m[5]||(m[5]=T=>Et(he(l)))},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-truck",size:"20"}),m[19]||(m[19]=F(" Zutaten einkaufen",-1))]),_:1})]),_:1}),he(i)?P("",!0):(w(),Q($,{key:5,onClick:m[6]||(m[6]=T=>Et(he(l))),to:"/recipes/edit?id="+p.value.id},{default:S(()=>[g(A,null,{default:S(()=>[g(_,{icon:"mdi-pencil",size:"20"}),m[20]||(m[20]=F(" Bearbeiten",-1))]),_:1})]),_:1},8,["to"])),g(k),g($,null,{default:S(()=>[I("div",tu,[g(_,{icon:"mdi-account-group",size:"20"}),m[21]||(m[21]=F(" Portionen ",-1))]),I("div",au,[(w(),z(_e,null,ke([1,2,3,4,5,6],T=>I("span",{key:T,class:"ml-1"},[g(x,{color:T===h.value?"indigo":null,"prepend-icon":"mdi-account",onClick:oe=>Da(T)},{default:S(()=>[F(ae(T),1)]),_:2},1032,["color","onClick"])])),64))])]),_:1})]),_:1})]),_:1})]),_:1}),p.value&&p.value.draftInProgress?(w(),Q(q,{key:0,type:"warning",color:"rgb(169, 209, 141)",onClick:He,style:{cursor:"pointer"},class:"mb-2"},{default:S(()=>[...m[22]||(m[22]=[F("Ein Entwurf wird gerade verarbeitet und anschlieÃŸend Ã¼bernommen. Bitte hier klicken um zu Aktualisieren.",-1)])]),_:1})):P("",!0),p.value?(w(),Q(we,{key:1,class:"pt-0"},{default:S(()=>[I("div",null,[I("div",su,[g(R,{variant:"plain","prepend-icon":"mdi-arrow-left",onClick:kt},{default:S(()=>[...m[23]||(m[23]=[F("ZurÃ¼ck",-1)])]),_:1})])]),I("div",ru,[!p.value.imageInProgress&&p.value.imageUploaded?(w(),Q(E,{key:0,height:"200",src:Aa(p.value),color:"grey",cover:""},null,8,["src"])):P("",!0),I("div",nu,ae(p.value.title),1)]),N.value?P("",!0):(w(),z("div",iu,[p.value.preheat?(w(),z("div",ou,ae(p.value.preheat),1)):P("",!0),(w(!0),z(_e,null,ke(wt.value,(T,oe)=>(w(),z("div",{key:T.index},[I("div",null,[I("h2",{style:{color:"dimgray"},class:"pt-8",id:"section-"+oe},[T.sectionTitle.startsWith(T.index)?P("",!0):(w(),z("span",lu,ae(T.index),1)),F(" "+ae(T.sectionTitle),1)],8,uu)]),Ve.value&&Ve.value.length>0&&xe.value===oe?(w(),z("div",pu,[g(G,{variant:"outlined"},{default:S(()=>[g(H,null,{default:S(()=>[(w(!0),z(_e,null,ke(Ve.value,(We,zt)=>(w(),z("div",{key:We.description},[zt!==0?(w(),Q(k,{key:0})):P("",!0),g(de,{class:"checkbox-top",modelValue:We.checked,"onUpdate:modelValue":[Ct=>We.checked=Ct,Ct=>za(zt)],"hide-details":"auto",density:"comfortable"},{label:S(()=>[I("span",{style:{"font-size":"1.2em"},innerHTML:Ie.value[We.taskNr+1]},null,8,mu)]),_:2},1032,["modelValue","onUpdate:modelValue"])]))),128))]),_:1})]),_:1})])):P("",!0),I("div",{style:{"font-size":"1.2em"},class:"mt-1",innerHTML:T.description,onClick:La,id:"sectionPart"},null,8,cu)]))),128))])),N.value?(w(),z("div",du,[m[26]||(m[26]=I("h2",null,"Vorbereitungen",-1)),he(i)?P("",!0):(w(),z("div",hu,[g(R,{onClick:$a,variant:"plain",rounded:"",style:{"font-size":"0.7em"}},{default:S(()=>[...m[24]||(m[24]=[F("ZurÃ¼cksetzen",-1)])]),_:1})])),m[27]||(m[27]=I("h3",null,"Zutatenvorbereitungen",-1)),he(_t).length===0?(w(),z("div",yu," Keine Vorbereitungen nÃ¶tig. ")):P("",!0),(w(!0),z(_e,null,ke(he(_t),T=>(w(),z("div",{class:"mt-1",key:T.name},[g(de,{modelValue:T.checked,"onUpdate:modelValue":oe=>T.checked=oe,"hide-details":"auto",density:"comfortable",label:T.name,onChange:Ot},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),m[28]||(m[28]=I("h3",{class:"mt-3"},"Rezeptvorbereitungen",-1)),I("span",fu,"Dauer: "+ae(he(ka))+" Min.",1),(w(!0),z(_e,null,ke(he(Oa),T=>(w(),z("div",{class:"mt-1",key:T.name},[g(de,{modelValue:T.checked,"onUpdate:modelValue":oe=>T.checked=oe,"hide-details":"auto",density:"comfortable",label:T.name,onChange:Ot},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),I("div",gu,[g(R,{onClick:At,color:"primary",variant:"outlined",rounded:""},{default:S(()=>[...m[25]||(m[25]=[F("Schnibbelmodus beenden",-1)])]),_:1})])])):P("",!0),I("div",bu,[he(i)?P("",!0):(w(),z("div",Nu,[m[29]||(m[29]=I("span",{style:{"font-size":"1.6em"}},"Wie hat das Essen geschmeckt?",-1)),I("div",vu,[g(ee,{"onUpdate:modelValue":[Pa,m[7]||(m[7]=T=>p.value.rating=T)],hover:"",length:"5",size:"30",modelValue:p.value.rating,"active-color":"primary"},null,8,["modelValue"])])])),I("div",Tu,[g(R,{variant:"text","prepend-icon":"mdi-arrow-left",style:{"font-size":"1.1em"},onClick:kt},{default:S(()=>[...m[30]||(m[30]=[F("ZurÃ¼ck zur Ãœbersicht",-1)])]),_:1})])]),m[31]||(m[31]=I("div",{style:{height:"600px"}},null,-1))]),_:1})):P("",!0),c.value?(w(),z("div",Su,[I("div",wu,[$e.value?(w(),z("div",_u,[I("div",ku,[g(Qe,{align:"center"},{default:S(()=>[g(Pe,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...m[32]||(m[32]=[F(" Das Rezept ist fÃ¼r heute geplant. Soll es auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Pe,{class:"d-flex align-center justify-end"},{default:S(()=>[g(R,{onClick:m[8]||(m[8]=T=>$e.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...m[33]||(m[33]=[F(" Nein ",-1)])]),_:1}),g(R,{onClick:Ye,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[F(" Ja ("+ae(Je.value)+") ",1)]),_:1})]),_:1})]),_:1})])])):P("",!0),Be.value?(w(),z("div",Ou,[I("div",Iu,[g(Qe,{align:"center"},{default:S(()=>[g(Pe,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...m[34]||(m[34]=[F(" Es wurde ein anderes Rezept geplant. Soll stattdessen dieses auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Pe,{class:"d-flex align-center justify-end"},{default:S(()=>[g(R,{onClick:m[9]||(m[9]=T=>Be.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...m[35]||(m[35]=[F(" Nein ",-1)])]),_:1}),g(R,{onClick:Ye,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[...m[36]||(m[36]=[F(" Ja ",-1)])]),_:1})]),_:1})]),_:1})])])):P("",!0),b.value?(w(),z("div",Eu,[g(we,{"max-width":"400"},{default:S(()=>[g(Ya,null,{default:S(()=>[I("tbody",null,[(w(!0),z(_e,null,ke(c.value,T=>(w(),z("tr",{key:T.name},[I("td",null,[T.amount?(w(),z("span",Au,ae(T.amount),1)):P("",!0),m[37]||(m[37]=F()),T.unit?(w(),z("span",$u,ae(T.unit),1)):P("",!0)]),I("td",null,ae(T.name),1)]))),128))])]),_:1})]),_:1})])):P("",!0),I("div",null,[d.value&&d.value.length>0?(w(),z("div",Du,[I("div",null,[g(R,{variant:"text",elevation:"0",disabled:"","prepend-icon":"mdi-timer-play-outline"},{default:S(()=>[...m[38]||(m[38]=[F("Stoppuhren",-1)])]),_:1})]),(w(!0),z(_e,null,ke(d.value,T=>(w(),z("div",{key:T.title,class:"my-1"},[g(k,{class:"mb-1"}),g(Qe,{align:"center"},{default:S(()=>[g(R,{icon:"mdi-close",onClick:oe=>ja(T.id),variant:"text"},null,8,["onClick"]),g(Pe,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[F(ae(T.title),1)]),_:2},1024),g(Pe,{class:"d-flex align-center justify-end"},{default:S(()=>[g(R,{onClick:oe=>Wa(T),icon:"mdi-minus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),g(R,{onClick:oe=>Ha(T),icon:"mdi-plus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),I("span",Pu,ae(Fa(T.remainingSeconds)),1),T.timerStarted?P("",!0):(w(),Q(R,{key:0,onClick:oe=>Ra(T),icon:"mdi-play-circle-outline",class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0"},null,8,["onClick"])),T.timerStarted?(w(),Q(R,{key:1,onClick:oe=>Ba(T),class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0",icon:""},{default:S(()=>[T.isPaused?(w(),z("span",zu,[g(_,{icon:"mdi-play-circle-outline"})])):P("",!0),T.isPaused?P("",!0):(w(),z("span",Cu,[g(_,{icon:"mdi-pause-circle-outline"})]))]),_:2},1032,["onClick"])):P("",!0)]),_:2},1024)]),_:2},1024)]))),128))])):P("",!0),I("div",xu,[I("span",Vu,[g(R,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:m[10]||(m[10]=T=>b.value=!b.value),elevation:"0","prepend-icon":"mdi-food-apple-outline"})]),I("span",Lu,[g(R,{color:"rgb(191, 231, 210)",style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",disabled:!C.value,onClick:It,elevation:"0","prepend-icon":"mdi-skip-forward"},{default:S(()=>[...m[39]||(m[39]=[F("NÃ¤chster Schritt",-1)])]),_:1},8,["disabled"])]),I("span",Fu,[g(R,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:Ca,disabled:!C.value,elevation:"0","prepend-icon":"mdi-arrow-down-right"},null,8,["disabled"])])])])])])):P("",!0),m[40]||(m[40]=I("div",{style:{display:"none"}},[I("iframe",{id:"scFrame",src:"/tfjs.html",allow:"microphone"})],-1)),g(is,{onResult:m[11]||(m[11]=T=>v.value=T)}),g(Yn,{onResult:m[12]||(m[12]=T=>j.value=T)}),I("video",{ref_key:"videoEl",ref:De,autoplay:"",playsinline:"",muted:"",style:{display:"none"}},null,512)])}}},Ru=oa(ju,[["__scopeId","data-v-ecd8c0f2"]]),Uu={__name:"index",setup(a){const e=ft(),t=rs();D(!1);const s=e.query.id;return gt(async()=>{s||t.push("/recipes")}),(i,n)=>(w(),Q(Ru))}};export{Uu as default};

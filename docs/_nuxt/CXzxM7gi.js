import{_ as Xt,O as Qt,K as Mt,r as C,u as ea,P as pt,o as mt,g as H,Q as te,y as _,C as S,B as g,z as I,x as L,S as Oe,T as Ie,R as V,A as re,D as j,L as kt,a6 as Ra,N as Ba,W as Ha,X as Wa,k as Ke,s as qa,e as Ga,U as we,a7 as Ua,a8 as Ka,J as Ja}from"./De8V3zEY.js";import{R as fe,I as Ya}from"./DNpDl8al.js";import{I as Za}from"./BO5j8faj.js";import{_ as Xa,a as F,e as ct,g as Qa,c as Ma,I as ta,b as es,i as ts,m as as,o as de,d as ss,E as oe,F as Ot,f as K,h as Ze,A as rs,B as ns,D as is,L as os,M as us,r as ae,j as ls,T as It,w as ps,v as ms,S as cs,k as ds,G as hs,s as ys,l as aa,n as sa,p as fs,q as gs,t as bs,u as Ns,x as vs,y as Ts,z as Et,C as At,H as Ss,J as ws,K as _s,N as ks,O as Os,P as Is,Q as Es,R as ge,U as As,V as $s,W as Ds,X as Ps,Y as zs,Z as Cs,$ as xs,a0 as Vs,a1 as Ls,a2 as Fs,a3 as js,a4 as Rs,a5 as ra,a6 as Bs,a7 as Hs,a8 as Ws,a9 as qs,aa as Gs,ab as Us,ac as Ks,ad as Js,ae as Ys,af as Zs,ag as Xs,ah as Qs,ai as Ms,aj as er,ak as tr,al as ar,am as sr,an as rr,ao as nr,ap as ir,aq as or,ar as ur,as as lr,at as pr,au as mr,av as cr,aw as dr,ax as hr,ay as yr,az as fr,aA as gr,aB as br,aC as Nr,aD as vr,aE as Tr,aF as Sr,aG as wr,aH as _r,aI as ve,aJ as _e,aK as Re,aL as Ve,aM as dt,aN as Le,aO as W,aP as ht,aQ as kr,aR as Or,aS as Ir,aT as Er,aU as Ar,aV as $r,aW as Dr,aX as Pr,aY as zr,aZ as Cr,a_ as xr,a$ as na,b0 as Vr,b1 as Lr,b2 as Fr,b3 as jr,b4 as Rr,b5 as Br,b6 as Hr,b7 as xe,b8 as Ee,b9 as $t,ba as Wr,bb as Dt,bc as qr,bd as Gr,be as Ur,bf as Kr,bg as Jr,bh as Yr,bi as Zr,bj as Xr,bk as Qr,bl as Mr,bm as en,bn as tn,bo as an,bp as sn,bq as rn,br as nn,bs as Pt,bt as on,bu as un,bv as ln,bw as pn,bx as mn,by as cn,bz as dn,bA as hn,bB as yn,bC as fn,bD as gn,bE as Xe,bF as bn,bG as zt,bH as Ct,bI as Nn,bJ as vn,bK as Tn,bL as Sn,bM as wn,bN as _n,bO as kn,bP as On,bQ as In,bR as En,bS as An,bT as Qe,bU as $n,bV as Dn,bW as Pn,bX as ia,bY as Je,bZ as zn,b_ as xt,b$ as Cn}from"./DZGTG2bd.js";import{G as Vt}from"./CI608YEO.js";const xn={class:"mt-3"},Vn={style:{"font-size":"1.6em"}},Ln={key:0,style:{"font-size":"1.3em","font-style":"italic"},class:"ml-4"},Fn={__name:"TimerDialog",emits:["result"],setup(a,{emit:e}){Qt();const t=Mt();C(t.authInfo);const s=e;ea(),pt().params.userId;const n=C(!1),o=C(null),u=C(null),l=C(!1),p=C([]);let m=null;mt(async()=>{s("result",async f=>(p.value=f,l.value=!1,m=new Audio("/audio/alert.mp3"),m.loop=!0,m.play(),setTimeout(()=>{h()},1e4),n.value=!0,new Promise((b,N)=>{o.value=b,u.value=N})))});function h(){m&&(m.pause(),m.currentTime=0,l.value=!0)}function d(){h(),n.value=!1,o.value(!1)}return(f,b)=>{const N=H("v-card-title"),v=H("v-divider"),R=H("v-card-text"),J=H("v-btn"),x=H("v-card-actions"),he=H("v-card"),B=H("v-dialog");return _(),te(B,{"max-width":"600",persistent:"",modelValue:n.value,"onUpdate:modelValue":b[0]||(b[0]=Y=>n.value=Y)},{default:S(()=>[g(he,{style:{"background-color":"#fcfaf7"},class:"pa-4"},{default:S(()=>[g(N,null,{default:S(()=>[...b[1]||(b[1]=[I("h2",null,"Zeit abgelaufen!",-1)])]),_:1}),g(R,null,{default:S(()=>[b[3]||(b[3]=I("div",{style:{width:"100%"},class:"text-center"},[I("div",{class:"vibrate"},[I("img",{alt:"bellring",src:Xa,style:{width:"300px",height:"300px"},class:"mt-2"})])],-1)),g(v),I("div",xn,[b[2]||(b[2]=I("h3",null,"Folgende Timer sind abgelaufen:",-1)),(_(!0),L(Oe,null,Ie(p.value,Y=>(_(),L("div",{key:Y.id},[I("span",Vn,"- "+re(Y.title),1),Y.descriptionTextAfter?(_(),L("div",Ln,re(Y.descriptionTextAfter),1)):V("",!0)]))),128))])]),_:1}),g(x,null,{default:S(()=>[g(J,{onClick:h,rounded:"",variant:"outlined",disabled:l.value},{default:S(()=>[...b[4]||(b[4]=[j(" Wecker stoppen ",-1)])]),_:1},8,["disabled"]),g(J,{onClick:d,rounded:"",variant:"outlined",color:"red"},{default:S(()=>[...b[5]||(b[5]=[j(" SchlieÃŸen ",-1)])]),_:1})]),_:1})]),_:1})]),_:1},8,["modelValue"])}}},jn=Xt(Fn,[["__scopeId","data-v-38b0a021"]]);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lt(a,e,t,s){o(a),t=t??0,s=s??1,u(t,s);let i=0;const n=l=>(l.then(p=>{const m=t+ ++i/a.length*(s-t);return e(m),p}),l);function o(l){F(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function u(l,p){F(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),F(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),F(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}return Promise.all(a.map(n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Rn(a,e){e==null&&(e={});const t=e.fetchFunc==null?ct().platform.fetch:e.fetchFunc,s=a.map(h=>t(h,e.requestInit,{isBinary:!0})),u=(e.onProgress==null?await Promise.all(s):await Lt(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(u):await Lt(u,e.onProgress,.5,1)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bn="application/octet-stream",Hn="application/json";class yt{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(F(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ct().platform.fetch,F(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&F(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:s};e.signature!=null&&(i.signature=e.signature),e.userDefinedMetadata!=null&&(i.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(i.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(i)],{type:Hn}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Bn}),"model.weights.bin");const n=await this.fetch(this.path,t);if(n.ok)return{modelArtifactsInfo:Qa(e),responses:[n]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${n.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let N=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?N+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":N+=" Please make sure the server is serving valid JSON for this request.",new Error(N)}const s=t.modelTopology,i=t.weightsManifest,n=t.generatedBy,o=t.convertedBy,u=t.format,l=t.signature,p=t.userDefinedMetadata;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let m,h;i!=null&&([m,h]=await this.loadWeights(i));const d={modelTopology:s,weightSpecs:m,weightData:h,generatedBy:n,convertedBy:o,format:u};l!=null&&(d.signature=l),p!=null&&(d.userDefinedMetadata=p);const f=t.modelInitializer;return f&&(d.modelInitializer=f),d}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=Wn(t),n=this.weightPathPrefix||s,o=[];for(const m of e)o.push(...m.weights);const u=[],l=[];for(const m of e)for(const h of m.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):u.push(n+h+i);this.weightUrlConverter&&u.push(...await Promise.all(l));const p=await Rn(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,Ma(p)]}}yt.URL_SCHEME_REGEX=/^https?:\/\//;function Wn(a){const e=a.lastIndexOf("/"),t=a.lastIndexOf("?"),s=a.substring(0,e),i=t>e?a.substring(t):"";return[s+"/",i]}function Ft(a){return a.match(yt.URL_SCHEME_REGEX)!=null}const oa=(a,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(a)?t=a.every(s=>Ft(s)):t=Ft(a),t)return ua(a,e)}return null};ta.registerSaveRouter(oa);ta.registerLoadRouter(oa);function ua(a,e){return new yt(a,e)}function jt(a,e){return ua(a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qn(a,e,t){if(es(a),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ts(a,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return as(a,e,s,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let De;function Gn(a,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(a==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,n=!1,o=!1,u=!1;if(a.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&a instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement)n=!0;else if(a.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&a instanceof ImageBitmap)u=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${a.constructor.name}`);if(i&&i&&a.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(ss(Ot,oe.backendName)!=null){const b={pixels:a},N={numChannels:e};return oe.runKernel(Ot,b,N)}const[p,m]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height];let h;o?h=a.getContext("2d").getImageData(0,0,p,m).data:s||t?h=a.data:(n||i||u)&&(De==null&&(De=document.createElement("canvas").getContext("2d")),De.canvas.width=p,De.canvas.height=m,De.drawImage(a,0,0,p,m),h=De.getImageData(0,0,p,m).data);let d;if(e===4)d=new Int32Array(h);else{const b=p*m;d=new Int32Array(b*e);for(let N=0;N<b;N++)for(let v=0;v<e;++v)d[N*e+v]=h[N*4+v]}return qn(d,[m,p,e],"int32")}const Un=de({fromPixels_:Gn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kn(a){F(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),F(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);const e=a.map((i,n)=>K(i,`tensors${n}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Ze(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return oe.runKernel(rs,s)}const Jn=de({addN_:Kn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(a,e,t){const s=K(a,"x","bincount"),i=K(e,"weights","bincount");F(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),F(t>=0,()=>`size must be non-negative, but got ${t}.`),F(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const n={x:s,weights:i},o={size:t};return oe.runKernel(ns,n,o)}const Zn=de({bincount_:Yn});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(a,e,t,s=!1){const i=K(a,"x","denseBincount"),n=K(e,"weights","denseBincount");F(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),F(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),F(t>=0,()=>`size must be non-negative, but got ${t}.`),F(n.size===i.size||n.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${n.shape}.`);const o={x:i,weights:n},u={size:t,binaryOutput:s};return oe.runKernel(is,o,u)}const Qn=de({denseBincount_:Xn});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(a,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:a,stop:e,num:t};return oe.runKernel(os,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(a,e,t,s,i=!1){const o={x:K(a,"x","maxPoolWithArgmax")},u={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},l=oe.runKernel(us,o,u);return{result:l[0],indexes:l[1]}}const ti=de({maxPoolWithArgmax_:ei});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ai(a,e,t,s=!1){const i=K(a,"logits","multinomial"),n=i.size,o=i.rank;if(n<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${n}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ae(i,[1,-1]):i},p={numSamples:e,seed:t,normalized:s},m=oe.runKernel(ls,l,p);return o===1?ae(m,[m.size]):m}const si=de({multinomial_:ai});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ri(a,e){const t=K(a,"x","setdiff1d"),s=K(e,"y","setdiff1d");F(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),F(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),F(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),n=await s.data(),o=new Set(n);let u=0;for(let m=0;m<i.length;m++)o.has(i[m])||u++;const l=new It([u],t.dtype),p=new It([u],"int32");for(let m=0,h=0;m<i.length;m++)o.has(i[m])||(l.values[h]=i[m],p.values[h]=m,h++);return[l.toTensor(),p.toTensor()]}const ni=ri;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ii(a){const e=K(a,"condition","whereAsync","bool"),t=await e.data(),s=ps(e.shape,t);return a!==e&&e.dispose(),s}const oi=ii;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(a,e,t){const s=K(a,"indices","scatterND","int32"),i=K(e,"updates","scatterND");ms(i,s,t);const n={indices:s,updates:i},o={shape:t};return oe.runKernel(cs,n,o)}const li=de({scatterND_:ui});function pi(a,e,t,s){if(a.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);const i=a.rank>0?a.shape[0]:1,n=a.rank>1?a.shape[1]:1;if(t.length!==n)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${n}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(a,e,t,s=0){const i=K(a,"sparseIndices","sparseToDense","int32"),n=K(e,"sparseValues","sparseToDense"),o=K(s,"defaultValue","sparseToDense",n.dtype);pi(i,n,t,o);const u={sparseIndices:i,sparseValues:n,defaultValue:o},l={outputShape:t};return oe.runKernel(ds,u,l)}const la=de({sparseToDense_:mi});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ci(a,e){const t=K(e,"indices","gatherND","int32"),i={params:K(a,"x","gatherND"),indices:t};return oe.runKernel(hs,i)}const di=de({gatherND_:ci});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hi({x:a,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:n=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:m}){if(ys(oe.state.gradientDepth,l)===!1){let B=aa(a,e,t,s,i,n,o);return u!=null&&(B=sa(B,u)),fs(B,l,p,m)}const h=K(a,"x","depthwiseConv2d"),d=K(e,"filter","depthwiseConv2d");let f=h,b=!1;h.rank===3&&(b=!0,f=ae(h,[1,h.shape[0],h.shape[1],h.shape[2]])),F(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),F(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),F(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),n==null&&(n=[1,1]),F(gs(t,n),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${n}'`),o!=null&&F(bs(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const N=Ns(f.shape,d.shape,t,n,s,o,!0);let v;u!=null&&(v=K(u,"bias","fused conv2d"),[v]=vs(v,h),Ts(N.outShape,v.shape));let R;p!=null&&(R=K(p,"prelu weights","fused depthwiseConv2d"));const J=(B,Y)=>{F(Ss(n),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${n}'`);const[q,se,Z,ue]=Y,M=ws(B,Z,l),ze=_s(se.shape,M,q,t,s,n,o),ke=ks(se,M,q.shape,t,s,n,o);if(ue!=null){const Te=Os(v,M);return[ze,ke,Te]}return[ze,ke]},x={x:f,filter:d,bias:v,preluActivationWeights:R},he={strides:t,pad:s,dataFormat:i,dilations:n,dimRoundingMode:o,activation:l,leakyreluAlpha:m};return u==null?Et((Y,q,se)=>{let Z=oe.runKernel(At,x,he);return se([q,Y,Z]),b&&(Z=ae(Z,[Z.shape[1],Z.shape[2],Z.shape[3]])),{value:Z,gradFunc:J}})(f,d):Et((Y,q,se,Z)=>{let ue=oe.runKernel(At,x,he);return Z([q,Y,ue,se]),b&&(ue=ae(ue,[ue.shape[1],ue.shape[2],ue.shape[3]])),{value:ue,gradFunc:J}})(f,d,v)}const yi=de({fusedDepthwiseConv2d_:hi});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fi={};function pa(a){return fi[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,e,t,s,i){const n=e.inputParams[a];if(n&&n.inputIndexStart!==void 0){const u=n.inputIndexStart,l=n.inputIndexEnd===0?void 0:n.inputIndexEnd===void 0?u+1:n.inputIndexEnd;if(n.type==="tensor")return ne(e.inputNames[n.inputIndexStart],t,s,i);if(n.type==="tensors")return e.inputNames.slice(u,l).map(d=>ne(d,t,s,i));const p=ne(e.inputNames.slice(u)[0],t,s,i),m=p.dataSync();return n.type==="number"?m[0]:Is(p.shape,m)}const o=e.attrParams[a];return o&&o.value}function ne(a,e,t,s){const[i,n]=ie(a);if(s!=null){const u=s.getHashTableHandleByName(i);if(u!=null)return u}const o=t.currentContextIds.find(u=>!!e[Be(i,u)]);return o!==void 0?e[Be(i,o)][n]:void 0}function gi(a,e,t){return e[Be(a,t.currentContextId)]}function be(a,e){const[t,s]=ie(a);return[Be(t,e&&e.currentContextId),s]}function Be(a,e){return e?`${a}-${e}`:a}function ie(a){const e=a.split(":");return e.length===1?[a,0]:[e[0],Number(e[e.length-1])]}function je(a,e,t){let s=r("pad",a,e,t);if(s==="explicit"){s=r("explicitPaddings",a,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let n=0;n<4;n++)i[n][0]=s[n*2],i[n][1]=s[n*2+1];return i}return s}function Ne(a){return a.kept?a:Es(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bi=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ni=Object.freeze(Object.defineProperty({__proto__:null,json:bi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vi=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ti=Object.freeze(Object.defineProperty({__proto__:null,json:vi},Symbol.toStringTag,{value:"Module"})),Si=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],wi=Object.freeze(Object.defineProperty({__proto__:null,json:Si},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _i=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],ki=Object.freeze(Object.defineProperty({__proto__:null,json:_i},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oi=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ii=Object.freeze(Object.defineProperty({__proto__:null,json:Oi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ei=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ai=Object.freeze(Object.defineProperty({__proto__:null,json:Ei},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $i=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Di=Object.freeze(Object.defineProperty({__proto__:null,json:$i},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],zi=Object.freeze(Object.defineProperty({__proto__:null,json:Pi},Symbol.toStringTag,{value:"Module"})),Ci=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],xi=Object.freeze(Object.defineProperty({__proto__:null,json:Ci},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],Li=Object.freeze(Object.defineProperty({__proto__:null,json:Vi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ji=Object.freeze(Object.defineProperty({__proto__:null,json:Fi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ri=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Bi=Object.freeze(Object.defineProperty({__proto__:null,json:Ri},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hi=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Wi=Object.freeze(Object.defineProperty({__proto__:null,json:Hi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qi=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Gi=Object.freeze(Object.defineProperty({__proto__:null,json:qi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ui=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Ki=Object.freeze(Object.defineProperty({__proto__:null,json:Ui},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ji=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yi=Object.freeze(Object.defineProperty({__proto__:null,json:Ji},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zi=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}],Xi=Object.freeze(Object.defineProperty({__proto__:null,json:Zi},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rt{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Ni,Ti,wi,ki,Ii,Ai,Di,ji,Li,zi,Bi,Wi,Gi,Ki,Yi,Xi,xi],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(e,t={}){const s=e.node,i=[],n=[],o=[],u=s.reduce((N,v)=>(N[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?i.push(N[v.name]):v.op==="Const"?n.push(N[v.name]):(v.input==null||v.input.length===0)&&o.push(N[v.name]),N),{});let l=[];const p=[];let m={},h={};t!=null&&(m=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(u);d.forEach(N=>{const v=u[N];v.inputNames.forEach(R=>{const[J]=be(R);v.inputs.push(u[J]),u[J].children.push(v)})}),Object.keys(h).length===0?d.forEach(N=>{const v=u[N];v.children.length===0&&p.push(v)}):Object.keys(h).forEach(N=>{const[v]=be(N),R=u[v];R!=null&&(R.signatureKey=h[N],p.push(R))}),Object.keys(m).length>0?Object.keys(m).forEach(N=>{const[v]=be(N),R=u[v];R&&(R.signatureKey=m[N],l.push(R))}):l=i;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((N,v)=>(N[v.signature.name]=this.mapFunction(v),N),{}));const b={nodes:u,inputs:l,outputs:p,weights:n,placeholders:i,signature:t,functions:f};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=pa(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.substr(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,n)=>(i[n.name]={type:n.type,inputIndexStart:n.start,inputIndexEnd:n.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,n)=>{const o=n.type;let u;switch(n.type){case"string":u=Me(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=Me(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":u=it(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=it(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":u=tt(e.attr,n.tfName,n.defaultValue||0),u===void 0&&n.tfDeprecatedName&&(u=tt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":u=nt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=nt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":u=et(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=et(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":u=ut(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ut(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":u=rt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=rt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":u=ot(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=ot(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":u=at(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=at(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":u=st(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=st(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":u=Bt(e.attr,n.tfName,n.defaultValue),u===void 0&&n.tfDeprecatedName&&(u=Bt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return i[n.name]={value:u,type:o},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let n={};t!=null&&(n=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&i.push(h[d.name]),h),{}));const o=[],u=[];e.signature.inputArg.forEach(h=>{const[d]=be(h.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ft(h.type),type:"dtype"}},children:[]};f.signatureKey=h.name,o.push(f),n[d]=f}),Object.keys(n).forEach(h=>{const d=n[h];d.inputNames.forEach(f=>{const[b]=be(f);d.inputs.push(n[b]),n[b].children.push(d)})});const p=e.ret;e.signature.outputArg.forEach(h=>{const[d,f]=be(p[h.name]),b=n[d];b!=null&&(b.defaultOutput=f,u.push(b))});const m=this.mapArgsToSignature(e);return{nodes:n,inputs:o,outputs:u,weights:i,placeholders:s,signature:m}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Qi(a){const e=ct().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ma(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):Qi(a);return e?t:t.toLowerCase()}function Me(a,e,t,s=!1){const i=a[e];return i!=null?ma(i.s,s):t}function et(a,e,t){const s=a[e];return s?s.b:t}function tt(a,e,t){const s=a[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function ft(a){switch(typeof a=="string"&&(a=ge[a]),a){case ge.DT_FLOAT:return"float32";case ge.DT_INT32:case ge.DT_INT64:case ge.DT_INT8:case ge.DT_UINT8:return"int32";case ge.DT_BOOL:return"bool";case ge.DT_DOUBLE:return"float32";case ge.DT_STRING:return"string";default:return null}}function Bt(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function at(a,e,t){const s=a[e];return s&&s.type?ft(s.type):t}function st(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(i=>ft(i)):t}function ca(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function rt(a,e,t){const s=a[e];return s&&s.shape?ca(s.shape):t}function nt(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function it(a,e,t,s=!1){const i=a[e];return i&&i.list&&i.list.s?i.list.s.map(n=>ma(n,s)):t}function ot(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>ca(i)):t}function ut(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mi{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,n)=>(i[n]=this.getAttr(n),i),{}))}getInput(e){return ne(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return ne(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return tt(this.node.rawAttrs,e,t);if(s.s!=null)return Me(this.node.rawAttrs,e,t);if(s.b!=null)return et(this.node.rawAttrs,e,t);if(s.shape!=null)return rt(this.node.rawAttrs,e,t);if(s.type!=null)return at(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return nt(this.node.rawAttrs,e,t);if(s.list.s!=null)return it(this.node.rawAttrs,e,t);if(s.list.shape!=null)return ot(this.node.rawAttrs,e,t);if(s.list.b!=null)return ut(this.node.rawAttrs,e,t);if(s.list.type!=null)return st(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eo=(a,e,t)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[sa(r("a",a,e,t),r("b",a,e,t))];case"AddN":return[Jn(r("tensors",a,e,t))];case"FloorMod":case"Mod":return[Fs(r("a",a,e,t),r("b",a,e,t))];case"Mul":return[Ls(r("a",a,e,t),r("b",a,e,t))];case"RealDiv":case"Div":return[Vs(r("a",a,e,t),r("b",a,e,t))];case"DivNoNan":return[xs(r("a",a,e,t),r("b",a,e,t))];case"FloorDiv":return[Cs(r("a",a,e,t),r("b",a,e,t))];case"Sub":return[zs(r("a",a,e,t),r("b",a,e,t))];case"Minimum":return[Ps(r("a",a,e,t),r("b",a,e,t))];case"Maximum":return[Ds(r("a",a,e,t),r("b",a,e,t))];case"Pow":return[$s(r("a",a,e,t),r("b",a,e,t))];case"SquaredDifference":return[As(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const to=(a,e,t)=>{switch(a.op){case"Abs":case"ComplexAbs":return[_r(r("x",a,e,t))];case"Acos":return[wr(r("x",a,e,t))];case"Acosh":return[Sr(r("x",a,e,t))];case"Asin":return[Tr(r("x",a,e,t))];case"Asinh":return[vr(r("x",a,e,t))];case"Atan":return[Nr(r("x",a,e,t))];case"Atan2":return[br(r("x",a,e,t),r("y",a,e,t))];case"Atanh":return[gr(r("x",a,e,t))];case"Ceil":return[fr(r("x",a,e,t))];case"Complex":return[yr(r("real",a,e,t),r("imag",a,e,t))];case"Cos":return[hr(r("x",a,e,t))];case"Cosh":return[dr(r("x",a,e,t))];case"Elu":return[cr(r("x",a,e,t))];case"Erf":return[mr(r("x",a,e,t))];case"Exp":return[pr(r("x",a,e,t))];case"Expm1":return[lr(r("x",a,e,t))];case"Floor":return[ur(r("x",a,e,t))];case"Log":return[or(r("x",a,e,t))];case"Log1p":return[ir(r("x",a,e,t))];case"Imag":return[nr(r("x",a,e,t))];case"Neg":return[rr(r("x",a,e,t))];case"Reciprocal":return[sr(r("x",a,e,t))];case"Real":return[ar(r("x",a,e,t))];case"Relu":return[tr(r("x",a,e,t))];case"Round":return[er(r("x",a,e,t))];case"Selu":return[Ms(r("x",a,e,t))];case"Sigmoid":return[Qs(r("x",a,e,t))];case"Sin":return[Xs(r("x",a,e,t))];case"Sign":return[Zs(r("x",a,e,t))];case"Sinh":return[Ys(r("x",a,e,t))];case"Softplus":return[Js(r("x",a,e,t))];case"Sqrt":return[Ks(r("x",a,e,t))];case"Square":return[Us(r("x",a,e,t))];case"Tanh":return[Gs(r("x",a,e,t))];case"Tan":return[qs(r("x",a,e,t))];case"ClipByValue":return[Ws(r("x",a,e,t),r("clipValueMin",a,e,t),r("clipValueMax",a,e,t))];case"Relu6":return[Hs(r("x",a,e,t))];case"Rsqrt":return[Bs(ne(a.inputNames[0],e,t))];case"Prod":return[ra(r("x",a,e,t),r("axes",a,e,t))];case"LeakyRelu":return[Rs(r("x",a,e,t),r("alpha",a,e,t))];case"Prelu":return[js(r("x",a,e,t),r("alpha",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function le(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){F(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const i=a[s],n=e[s];F(i<0||n<0||i===n,()=>t+` Shapes ${a} and ${e} must match`)}}}function Ht(a){return!(typeof a=="number"||a.some(e=>e<0))}function Ce(a,e,t){let s=lt(a,t);const i=!Ht(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(n=>{s=lt(n.shape,s)}),!Ht(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function lt(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const i=a[s],n=e[s];if(i>=0&&n>=0&&i!==n)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=i>=0?i:n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ao{constructor(e,t,s,i,n,o,u){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=n,this.dynamicSize=o,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=ve(0),_e(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),le(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,_e(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Re([],[0].concat(this.elementShape));const s=this.readMany(e);return le(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Ve(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Re([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return le(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),dt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Le(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const n=s===0?0:t.size/s,o=[];W(()=>{t=ae(t,[1,s,n]);for(let l=0;l<e.length;++l){const m=[0,l===0?0:i[l-1],0],h=[1,e[l],n];o[l]=ae(ht(t,m,h),this.elementShape)}return o});const u=[];for(let l=0;l<e.length;l++)u[l]=l;this.writeMany(u,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pe{constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(n=>{if(s!==n.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${n.dtype}`);le(t,n.shape,"TensorList shape mismatch: "),_e(n)}),this.idTensor=ve(0),this.maxNumElements=i,_e(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Pe([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);le(e,this.elementShape,"TensorList shape mismatch: ");const i=Ce(this.elementShape,this.tensors,e);return W(()=>{const n=this.tensors.map(o=>ae(o,i));return Ve(n,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Ce(this.elementShape,this.tensors,e),i=this.tensors.pop();return le(i.shape,e,"TensorList shape mismatch: "),ae(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(le(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");_e(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);le(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Ce(this.elementShape,this.tensors,t);return ae(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);le(this.elementShape,t.shape,"TensorList shape mismatch: "),_e(t),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);le(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Ce(this.elementShape,this.tensors,s);return e.length===0?Re([],[0].concat(i)):W(()=>{const n=e.map(o=>ae(this.tensors[o],i));return Ve(n,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);le(this.elementShape,t,"TensorList shape mismatch: ");const s=Ce(this.elementShape,this.tensors,t);return this.size()===0?Re([],[0].concat(s)):W(()=>{const i=this.tensors.map(n=>ae(n,s));return dt(i,0)})}}function so(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const i=a.shape.slice(1);le(i,e,"TensorList shape mismatch: ");const n=Le(a);return new Pe(n,e,s)}function ro(a,e,t){return new Pe([],a,e,t)}function no(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const n=new Pe([],t,a.dtype,s),o=Le(a,0);return e.forEach((u,l)=>{n.setItem(u,o[l])}),n}function io(a,e,t){let s=0;const i=e.map(m=>(s+=m,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const n=a.shape.slice(1),o=lt(n,t),u=s===0?0:a.size/s,l=W(()=>{const m=[];a=ae(a,[1,s,u]);for(let h=0;h<e.length;++h){const f=[0,h===0?0:i[h-1],0],b=[1,e[h],u];m[h]=ae(ht(a,f,b),o)}return a.dispose(),m}),p=new Pe([],t,a.dtype,e.length);for(let m=0;m<l.length;m++)p.setItem(m,l[m]);return p}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=r("thenBranch",a,e,t),i=r("elseBranch",a,e,t),n=r("cond",a,e,t),o=r("args",a,e,t);return(await n.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=r("body",a,e,t),i=r("cond",a,e,t),n=r("args",a,e,t),o=await t.functionMap[i].executeFunctionAsync(n,t.tensorArrayMap,t.tensorListMap),u=n.map(m=>m.id);let l=await o[0].data();o.forEach(m=>{!m.kept&&u.indexOf(m.id)===-1&&m.dispose()});let p=n;for(;l[0];){const m=p;p=await t.functionMap[s].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);const h=p.map(f=>f.id);m.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()});const d=await t.functionMap[i].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(f=>{!f.kept&&u.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()})}return p}case"LoopCond":{const s=r("pred",a,e,t);return[Ne(s)]}case"Switch":{const s=r("pred",a,e,t);let i=r("data",a,e,t);return i.kept||(i=Ne(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=a.inputNames.find(i=>ne(i,e,t)!==void 0);if(s){const i=ne(s,e,t);return[Ne(i)]}return}case"Enter":{const s=r("frameName",a,e,t),i=r("tensor",a,e,t);return t.enterFrame(s),[Ne(i)]}case"Exit":{const s=r("tensor",a,e,t);return t.exitFrame(),[Ne(s)]}case"NextIteration":{const s=r("tensor",a,e,t);return t.nextIteration(),[Ne(s)]}case"TensorArrayV3":{const s=r("size",a,e,t),i=r("dtype",a,e,t),n=r("elementShape",a,e,t),o=r("dynamicSize",a,e,t),u=r("clearAfterRead",a,e,t),l=r("identicalElementShapes",a,e,t),p=r("name",a,e,t),m=new ao(p,i,s,n,l,o,u);return t.addTensorArray(m),[m.idTensor,ve(1)]}case"TensorArrayWriteV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.write(i,n),[o.idTensor]}case"TensorArrayReadV3":{const s=r("tensorArrayId",a,e,t),i=r("index",a,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("dtype",a,e,t);return[t.getTensorArray(s.id).gather(i,n)]}case"TensorArrayScatterV3":{const s=r("tensorArrayId",a,e,t),i=r("indices",a,e,t),n=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.scatter(i,n),[o.idTensor]}case"TensorArrayConcatV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id),n=r("dtype",a,e,t);return[i.concat(n)]}case"TensorArraySplitV3":{const s=r("tensorArrayId",a,e,t),i=r("tensor",a,e,t),n=r("lengths",a,e,t),o=t.getTensorArray(s.id);return o.split(n,i),[o.idTensor]}case"TensorArraySizeV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return[ve(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=r("tensorArrayId",a,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("tensor",a,e,t),o=t.getTensorList(s.id);return o.setItem(i,n),[o.idTensor]}case"TensorListGetItem":{const s=r("tensorListId",a,e,t),i=r("index",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(i,n,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=r("indices",a,e,t),i=r("tensor",a,e,t),n=r("elementShape",a,e,t),o=r("numElements",a,e,t),u=no(i,s,n,o);return t.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=r("elementShape",a,e,t),i=r("elementDType",a,e,t);let n;a.op==="TensorListReserve"?n="numElements":n="maxNumElements";const o=r(n,a,e,t),u=ro(s,i,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=r("tensorListId",a,e,t),i=r("indices",a,e,t),n=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).gather(i,o,n)]}case"TensorListStack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=r("numElements",a,e,t);return[t.getTensorList(s.id).stack(i,n,o)]}case"TensorListFromTensor":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t),o=so(s,i,n);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const s=r("tensorListId",a,e,t),i=t.getTensorList(s.id),n=r("dtype",a,e,t),o=r("elementShape",a,e,t);return[i.concat(n,o)]}case"TensorListPushBack":{const s=r("tensorListId",a,e,t),i=r("tensor",a,e,t),n=t.getTensorList(s.id);return n.pushBack(i),[n.idTensor]}case"TensorListPopBack":{const s=r("tensorListId",a,e,t),i=r("elementShape",a,e,t),n=r("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(i,n)]}case"TensorListSplit":{const s=r("tensor",a,e,t),i=r("elementShape",a,e,t),n=r("lengths",a,e,t),o=io(s,n,i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wt(a,e,t){const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=s==="fusedbatchnorm",l=r("numArgs",a,e,t);if(n){if(o&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const p=r("strides",a,e,t),m=je(a,e,t),h=r("dataFormat",a,e,t).toUpperCase(),d=r("dilations",a,e,t),[f,b]=r("args",a,e,t),N=r("leakyreluAlpha",a,e,t);return{stride:p,pad:m,dataFormat:h,dilations:d,biasArg:f,preluArg:b,activationFunc:i,leakyreluAlpha:N}}const uo=(a,e,t)=>{switch(a.op){case"Conv1D":{const s=r("stride",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilation",a,e,t);return[Cr(r("x",a,e,t),r("filter",a,e,t),s,i,n,o)]}case"Conv2D":{const s=r("strides",a,e,t),i=je(a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[zr(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,n,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=Wt(a,e,t);return[Pr({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:n,dilations:o,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=Wt(a,e,t);return[yi({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[s[1],s[2]],pad:i,dataFormat:n,dilations:[o[1],o[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=r("outputShape",a,e,t),i=r("strides",a,e,t),n=je(a,e,t);return[Dr(r("x",a,e,t),r("filter",a,e,t),s,[i[1],i[2]],n)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=r("strides",a,e,t),i=je(a,e,t),n=r("dilations",a,e,t),o=r("dataFormat",a,e,t).toUpperCase();return[aa(r("input",a,e,t),r("filter",a,e,t),[s[1],s[2]],i,o,[n[1],n[2]])]}case"Conv3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dataFormat",a,e,t).toUpperCase(),o=r("dilations",a,e,t);return[$r(r("x",a,e,t),r("filter",a,e,t),[s[1],s[2],s[3]],i,n,[o[1],o[2],o[3]])]}case"AvgPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Ar(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Er(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t),o=r("includeBatchInIndex",a,e,t),{result:u,indexes:l}=ti(r("x",a,e,t),[n[1],n[2]],[s[1],s[2]],i,o);return[u,l]}case"AvgPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Ir(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("kernelSize",a,e,t);return[Or(r("x",a,e,t),[n[1],n[2],n[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=r("strides",a,e,t),i=r("pad",a,e,t),n=r("dilations",a,e,t),o=s[1],u=s[2],l=n[1],p=n[2];return[kr(r("x",a,e,t),r("filter",a,e,t),[o,u],i,[l,p],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lo=(a,e,t)=>{switch(a.op){case"Fill":{const s=r("shape",a,e,t),i=r("dtype",a,e,t),n=r("value",a,e,t);return[Hr(s,n,i)]}case"LinSpace":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("num",a,e,t);return[Mn(s,i,n)]}case"Multinomial":{const s=r("logits",a,e,t),i=r("numSamples",a,e,t),n=r("seed",a,e,t);return[si(s,i,n)]}case"OneHot":{const s=r("indices",a,e,t),i=r("depth",a,e,t),n=r("onValue",a,e,t),o=r("offValue",a,e,t);return[Br(s,i,n,o)]}case"Ones":return[Rr(r("shape",a,e,t),r("dtype",a,e,t))];case"OnesLike":return[jr(r("x",a,e,t))];case"RandomUniform":return[Fr(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("dtype",a,e,t))];case"Range":{const s=r("start",a,e,t),i=r("stop",a,e,t),n=r("step",a,e,t);return[Lr(s,i,n,r("dtype",a,e,t))]}case"TruncatedNormal":{const s=r("shape",a,e,t),i=r("mean",a,e,t),n=r("stdDev",a,e,t),o=r("seed",a,e,t);return[Vr(s,i,n,r("dtype",a,e,t),o)]}case"Zeros":return[na(r("shape",a,e,t),r("dtype",a,e,t))];case"ZerosLike":return[xr(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ye(a,e,t){const s=r("boxes",a,e,t),i=r("scores",a,e,t),n=r("maxOutputSize",a,e,t),o=r("iouThreshold",a,e,t),u=r("scoreThreshold",a,e,t),l=r("softNmsSigma",a,e,t);return{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}}const po=async(a,e,t)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=Ye(a,e,t),p=await Ee.nonMaxSuppressionWithScoreAsync(s,i,n,o,u,l);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=Ye(a,e,t),l=r("padToMaxOutputSize",a,e,t),p=await Ee.nonMaxSuppressionPaddedAsync(s,i,n,o,u,l);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:i,maxOutputSize:n,iouThreshold:o,scoreThreshold:u}=Ye(a,e,t);return[await Ee.nonMaxSuppressionAsync(s,i,n,o,u)]}case"Where":{const s=xe(r("condition",a,e,t),"bool"),i=[await oi(s)];return s.dispose(),i}case"ListDiff":return ni(r("x",a,e,t),r("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=(a,e,t)=>{switch(a.op){case"TopKV2":{const s=r("x",a,e,t),i=r("k",a,e,t),n=r("sorted",a,e,t),o=Wr(s,i,n);return[o.values,o.indices]}case"Unique":{const s=r("x",a,e,t),i=$t(s);return[i.values,i.indices]}case"UniqueV2":{const s=r("x",a,e,t),i=r("axis",a,e,t),n=$t(s,i);return[n.values,n.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co=(a,e,t)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const s=r("default",a,e,t);return[ne(a.name,e,t)||s];case"Placeholder":return[ne(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=r("x",a,e,t);return[Ne(p)]}case"IdentityN":return r("x",a,e,t).map(p=>Ne(p));case"Snapshot":const i=r("x",a,e,t);return[Ne(i)];case"Shape":return[Dt(r("x",a,e,t).shape,"int32")];case"ShapeN":return r("x",a,e,t).map(p=>Dt(p.shape));case"Size":return[ve(r("x",a,e,t).size,"int32")];case"Rank":return[ve(r("x",a,e,t).rank,"int32")];case"NoOp":return[ve(1)];case"Print":const n=r("x",a,e,t),o=r("data",a,e,t),u=r("message",a,e,t),l=r("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,l));return[n];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ho{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ve(0),this.tensorMap=new Map,_e(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),W(()=>{const i=Le(t),n=s.length,o=i.length;F(n===o,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${o} elements.`);for(let u=0;u<n;u++){const l=s[u],p=i[u];_e(p),this.tensorMap.set(l,p)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return W(()=>{const i=[];for(let n=0;n<s.length;n++){const o=s[n],u=this.findWithDefault(o,t);i.push(u)}return Ve(i)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const i=r("keyDType",a,e,t),n=r("valueDType",a,e,t),o=new ho(i,n);return s.addHashTable(a.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("values",a,e,t);return[await s.getHashTableById(i.id).import(n,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=r("tableHandle",a,e,t,s),n=r("keys",a,e,t),o=r("defaultValue",a,e,t);return[await s.getHashTableById(i.id).find(n,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=r("tableHandle",a,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=(a,e,t)=>{switch(a.op){case"ResizeBilinear":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Ee.resizeBilinear(s,[i[0],i[1]],n,o)]}case"ResizeNearestNeighbor":{const s=r("images",a,e,t),i=r("size",a,e,t),n=r("alignCorners",a,e,t),o=r("halfPixelCenters",a,e,t);return[Ee.resizeNearestNeighbor(s,[i[0],i[1]],n,o)]}case"CropAndResize":{const s=r("image",a,e,t),i=r("boxes",a,e,t),n=r("boxInd",a,e,t),o=r("cropSize",a,e,t),u=r("method",a,e,t),l=r("extrapolationValue",a,e,t);return[Ee.cropAndResize(s,i,n,o,u,l)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go=(a,e,t)=>{switch(a.op){case"Equal":return[Mr(r("a",a,e,t),r("b",a,e,t))];case"NotEqual":return[Qr(r("a",a,e,t),r("b",a,e,t))];case"Greater":return[Xr(r("a",a,e,t),r("b",a,e,t))];case"GreaterEqual":return[Zr(r("a",a,e,t),r("b",a,e,t))];case"Less":return[Yr(r("a",a,e,t),r("b",a,e,t))];case"LessEqual":return[Jr(r("a",a,e,t),r("b",a,e,t))];case"LogicalAnd":return[Kr(r("a",a,e,t),r("b",a,e,t))];case"LogicalNot":return[Ur(r("a",a,e,t))];case"LogicalOr":return[Gr(r("a",a,e,t),r("b",a,e,t))];case"Select":case"SelectV2":return[qr(r("condition",a,e,t),r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo=(a,e,t)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[an(r("a",a,e,t),r("b",a,e,t),r("transposeA",a,e,t),r("transposeB",a,e,t))];case"Transpose":return[tn(r("x",a,e,t),r("perm",a,e,t))];case"_FusedMatMul":const[s,i]=r("fusedOps",a,e,t),n=s==="biasadd",o=i==="prelu",u=r("numArgs",a,e,t),l=r("leakyreluAlpha",a,e,t);if(n){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,m]=r("args",a,e,t);return[en({a:r("a",a,e,t),b:r("b",a,e,t),transposeA:r("transposeA",a,e,t),transposeB:r("transposeB",a,e,t),bias:p,activation:i,preluActivationWeights:m,leakyreluAlpha:l})];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No=(a,e,t)=>{switch(a.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Pt(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"FusedBatchNormV3":return[Pt(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"LRN":return[nn(r("x",a,e,t),r("radius",a,e,t),r("bias",a,e,t),r("alpha",a,e,t),r("beta",a,e,t))];case"Softmax":return[rn(r("x",a,e,t))];case"LogSoftmax":return[sn(r("x",a,e,t))];case"SparseToDense":return[la(r("sparseIndices",a,e,t),r("outputShape",a,e,t),r("sparseValues",a,e,t),r("defaultValue",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=(a,e,t)=>{switch(a.op){case"Max":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[yn(r("x",a,e,t),o,u)]}case"Mean":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[hn(r("x",a,e,t),o,u)]}case"Min":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[dn(r("x",a,e,t),o,u)]}case"Sum":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[cn(r("x",a,e,t),o,u)]}case"All":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[mn(r("x",a,e,t),o,u)]}case"Any":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[pn(r("x",a,e,t),o,u)]}case"ArgMax":{const o=r("axis",a,e,t);return[ln(r("x",a,e,t),o)]}case"ArgMin":{const o=r("axis",a,e,t);return[un(r("x",a,e,t),o)]}case"Prod":{const o=r("axis",a,e,t),u=r("keepDims",a,e,t);return[ra(r("x",a,e,t),o,u)]}case"Cumsum":{const o=r("axis",a,e,t),u=r("exclusive",a,e,t),l=r("reverse",a,e,t);return[on(r("x",a,e,t),o,u,l)]}case"Bincount":const s=r("x",a,e,t),i=r("weights",a,e,t),n=r("size",a,e,t);return[Zn(s,i,n)];case"DenseBincount":{const o=r("x",a,e,t),u=r("weights",a,e,t),l=r("size",a,e,t),p=r("binaryOutput",a,e,t);return[Qn(o,u,l,p)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const To=(a,e,t)=>{switch(a.op){case"ConcatV2":case"Concat":{const s=r("n",a,e,t),i=r("axis",a,e,t);let n=r("tensors",a,e,t);return n=n.slice(0,s),[dt(n,i)]}case"Gather":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[Ct(s,xe(i,"int32"),0)]}case"GatherV2":{const s=r("axis",a,e,t),i=r("batchDims",a,e,t),n=r("x",a,e,t),o=r("indices",a,e,t);return[Ct(n,xe(o,"int32"),s,i)]}case"Reverse":{const s=r("dims",a,e,t),i=[];for(let o=0;o<s.length;o++)s[o]&&i.push(o);const n=r("x",a,e,t);return[zt(n,i)]}case"ReverseV2":{const s=r("axis",a,e,t),i=r("x",a,e,t);return[zt(i,s)]}case"Slice":{const s=r("begin",a,e,t),i=r("size",a,e,t);return[ht(r("x",a,e,t),s,i)]}case"StridedSlice":{const s=r("begin",a,e,t),i=r("end",a,e,t),n=r("strides",a,e,t),o=r("beginMask",a,e,t),u=r("endMask",a,e,t),l=r("ellipsisMask",a,e,t),p=r("newAxisMask",a,e,t),m=r("shrinkAxisMask",a,e,t),h=r("x",a,e,t);return[bn(h,s,i,n,o,u,l,p,m)]}case"Pack":return W(()=>{const s=r("axis",a,e,t),i=r("tensors",a,e,t),n=i[0].shape,o=Xe(i[0]).shape,u=i.map(l=>{const p=Ze(l.shape,n);if(!p&&!Ze(Xe(l).shape,o))throw new Error("the input tensors shape does not match");return p?l:ae(l,n)});return[Ve(u,s)]});case"Unpack":{const s=r("axis",a,e,t),i=r("tensor",a,e,t);return Le(i,s)}case"Tile":{const s=r("reps",a,e,t);return[gn(r("x",a,e,t),s)]}case"Split":case"SplitV":{const s=r("axis",a,e,t),i=r("numOrSizeSplits",a,e,t),n=r("x",a,e,t);return fn(n,i,s)}case"ScatterNd":{const s=r("indices",a,e,t),i=r("values",a,e,t),n=r("shape",a,e,t);return[li(s,i,n)]}case"GatherNd":{const s=r("x",a,e,t),i=r("indices",a,e,t);return[di(s,i)]}case"SparseToDense":{const s=r("sparseIndices",a,e,t),i=r("outputShape",a,e,t),n=r("sparseValues",a,e,t),o=r("defaultValue",a,e,t);return[la(s,n,i,n.dtype===o.dtype?o:xe(o,n.dtype))]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So=(a,e,t)=>{switch(a.op){case"FFT":return[Sn(r("x",a,e,t))];case"IFFT":return[Tn(r("x",a,e,t))];case"RFFT":return[vn(r("x",a,e,t))];case"IRFFT":return[Nn(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo=(a,e,t)=>{switch(a.op){case"Cast":return[xe(r("x",a,e,t),r("dtype",a,e,t))];case"ExpandDims":{const s=r("axis",a,e,t);return[An(r("x",a,e,t),s)]}case"Squeeze":{const s=r("axis",a,e,t);return[Xe(r("x",a,e,t),s)]}case"Reshape":return[ae(r("x",a,e,t),r("shape",a,e,t))];case"MirrorPad":return[En(r("x",a,e,t),r("padding",a,e,t),r("mode",a,e,t))];case"PadV2":case"Pad":return[In(r("x",a,e,t),r("padding",a,e,t),r("constantValue",a,e,t))];case"SpaceToBatchND":{const s=r("blockShape",a,e,t),i=r("paddings",a,e,t);return[On(r("x",a,e,t),s,i)]}case"BatchToSpaceND":{const s=r("blockShape",a,e,t),i=r("crops",a,e,t);return[kn(r("x",a,e,t),s,i)]}case"DepthToSpace":{const s=r("blockSize",a,e,t),i=r("dataFormat",a,e,t).toUpperCase();return[_n(r("x",a,e,t),s,i)]}case"BroadcastTo":return[wn(r("x",a,e,t),r("shape",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qt(a,e,t,s){const i=((n,o,u)=>{switch(n.category){case"arithmetic":return W(()=>eo(n,o,u));case"basic_math":return W(()=>to(n,o,u));case"control":return oo(n,o,u);case"convolution":return W(()=>uo(n,o,u));case"creation":return W(()=>lo(n,o,u));case"dynamic":return po(n,o,u);case"evaluation":return W(()=>mo(n,o,u));case"image":return W(()=>fo(n,o,u));case"graph":return W(()=>co(n,o,u));case"logical":return W(()=>go(n,o,u));case"matrices":return W(()=>bo(n,o,u));case"normalization":return W(()=>No(n,o,u));case"reduction":return W(()=>vo(n,o,u));case"slice_join":return W(()=>To(n,o,u));case"spectral":return W(()=>So(n,o,u));case"transformation":return W(()=>wo(n,o,u));case"hash_table":return yo(n,o,u,s);case"custom":const l=pa(n.op);if(l&&l.customExecutor)return l.customExecutor(new Mi(n,o,u));throw TypeError(`Custom op ${n.op} is not registered.`);default:throw TypeError(`Unknown op '${n.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return Qe(i)?i.then(n=>[].concat(n)):[].concat(i)}class Gt{constructor(e={},t={},s={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ut(a,e,t,s){const i=new Set,n=[];let o=null,u=null;const l=new Set,p=Object.keys(a).map(d=>ie(d)[0]);let m=[];s!=null&&(m=s.map(d=>ie(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((da(d)||Eo(d)||Ao(d))&&o==null&&(o=d,u=o.children.map(f=>f.name).filter(f=>i.has(f))),i.add(d.name),t[d.name]==null&&p.indexOf(d.name)===-1&&m.indexOf(d.name)===-1){if(d.inputs.length===0){n.push(d.name);continue}d.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),h.push(f))})}}return{inputs:a,outputs:e,usedNodes:i,missingInputs:n,dynamicNode:o,syncInputs:u}}function _o(a,e,t){const{usedNodes:s,inputs:i}=t,n=[],o=Object.keys(i).map(m=>ie(m)[0]).map(m=>a.nodes[m]),u=a.initNodes;o.forEach(m=>{s.has(m.name)&&n.push(m)}),a.weights.forEach(m=>{s.has(m.name)&&n.push(m)}),u!=null&&u.forEach(m=>{s.has(m.name)&&n.push(m)});const l=new Set,p=[];for(;n.length>0;){const m=n.pop();l.add(m.name),e[m.name]||p.push(m),m.children.forEach(h=>{!l.has(h.name)&&s.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&n.push(h)})}return p}const ko=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Oo=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Io=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function da(a){return ko.indexOf(a.op)>=0}function Eo(a){return Oo.indexOf(a.op)>=0}function Ao(a){return Io.indexOf(a.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class He{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new He(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(n=>n.name).sort(),i=t.map(n=>n.name).sort();return s.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const s=Ut(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:n,syncInputs:o}=s;if(n!=null)throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const u=t.map(p=>p.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return _o(this.graph,this.weightMap,s)}execute(e,t){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(h=>this.graph.nodes[ie(h)[0]]),n=t.map(h=>ie(h)[0]);let o=n.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(i,o);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,o),this.compiledMap.set(u,l));const p={},m={};return W(()=>{const h=new Gt(this.weightMap,p,m,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[v,R]=ie(N),J=[];J[R]=e[N],d[v]=J});const f=this.getFrozenTensorIds(d),b={};for(let N=0;N<l.length;N++){const v=l[N];if(!d[v.name]){const R=qt(v,d,h,this._resourceManager);if(Qe(R))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);d[v.name]=R,this.checkTensorForDisposal(v.name,v,d,h,f,n,b)}}return this.parent==null&&h.dispose(f),t.map(N=>ne(N,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,n,o,u){t.category==="control"||o.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(u[l.id]=(u[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const p=gi(l.name,s,i);p!=null&&p.forEach(m=>{if(m&&!n.has(m.id)){const h=u[m.id];h===1?(m.dispose(),delete u[m.id]):h!=null&&u[m.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,s=!1,i={},n={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const o=new Gt(this.weightMap,i,n,this.functionExecutorMap),u=await this.executeWithControlFlow(e,o,t,s),l=t.map(d=>ne(d,u,o)),p=l.map(d=>d.id),m=Object.keys(e).map(d=>e[d].id),h=new Set([...p,...m,...this.weightIds]);return Object.keys(u).forEach(d=>{u[d].forEach(b=>{b&&!b.isDisposed&&!h.has(b.id)&&b.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,s){const i=e.reduce((n,o,u)=>(n[this.inputs[u].name]=o,n),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const n=Object.keys(e),o=n.map(x=>this.graph.nodes[ie(x)[0]]),u=s.map(x=>ie(x)[0]);let l=u.map(x=>this.graph.nodes[x]);l.length===0&&(l=this._outputs);const{usedNodes:p,missingInputs:m,dynamicNode:h,syncInputs:d}=Ut(e,l,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[he,B]=ie(x),Y=[];Y[B]=e[x],b[he]=Y});const N={},v=this.getFrozenTensorIds(b),R={};for(;f.length>0;){const x=this.processStack(o,f,t,b,R,v,u,N,p);await Promise.all(x)}h==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const J=l.filter(x=>!da(x)&&!ne(x.name,b,t)).map(x=>x.name);if(J.length>0){let x="";throw h!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${J}] from the provided inputs [${n}]. Consider providing the following inputs: [${m}]. ${x}`)}return b}processStack(e,t,s,i,n,o,u,l,p){const m=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&r("isConstant",h.node,i,s)&&([d]=be(h.node.name,s)),i[h.node.name]==null){const f=qt(h.node,i,s,this._resourceManager);d||([d]=be(h.node.name,s));const b=s.currentContext;Qe(f)?m.push(f.then(N=>(i[d]=N,s.currentContext=b,this.checkTensorForDisposal(d,h.node,i,s,o,u,l),this.processChildNodes(h.node,t,s,i,n,p),N))):(i[d]=f,this.checkTensorForDisposal(d,h.node,i,s,o,u,l),this.processChildNodes(h.node,t,s,i,n,p))}else this.processChildNodes(h.node,t,s,i,n,p)}return m}processChildNodes(e,t,s,i,n,o){e.children.forEach(u=>{const[l]=be(u.name,s);n[l]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(p=>!!ne(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})):u.inputNames.every(p=>!!ne(p,i,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=ie(t),n=this.graph.nodes[i];if(n.attrParams.shape&&n.attrParams.shape.value){const o=n.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((l,p)=>o[p]===-1||o[p]===l);F(u,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&F(s.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const t={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const i=this._signature.inputs[s];t[i.name]=e[s]}else t[s]=e[s];return t}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=ie(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[s]=ie(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class $o{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Do="?tfjs-format=file",Po="model.json";class zo{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new $o}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=jt(e,this.loadOptions);else{const t=$n(e,this.loadOptions);if(t.length===0)t.push(jt(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=Dn(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new He(Rt.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const n=Rt.Instance.transformGraph(e.modelInitializer);this.initializer=new He(n),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=Pn(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ia)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,s,i)=>(t[s]=e[i],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Co(a,e={}){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&a.load==null&&(a.endsWith("/")||(a=a+"/"),a=`${a}${Po}${Do}`);const t=new zo(a,e);return await t.load(),t}/**
 * @license
 * Copyright 2019 Victor Dibia.
 * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.
 * Licensed under the MIT License (the "License");
 * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd
 * =============================================================================
 */const xo="https://cdn.jsdelivr.net/npm/handtrackjs@latest/models/webmodel/",Vo={1:"open",2:"closed",3:"pinch",4:"point",5:"face",6:"pointtip",7:"pinchtip"},Lo={flipHorizontal:!1,outputStride:16,imageScaleFactor:1,maxNumBoxes:20,iouThreshold:.2,scoreThreshold:.6,modelType:"ssd320fpnlite",modelSize:"small",bboxLineWidth:"2",fontSize:17,basePath:xo,labelMap:Vo,renderThresholds:null},Fo={large:"base",medium:"fp16",small:"int8"},Kt={open:"#374151",closed:"#B91C1C",pinch:"#F59E0B",point:"#10B981",face:"#3B82F6",pointtip:"#6366F1",pinchtip:"#EC4899"},Jt={ssd320fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],ssd640fpnlite:["StatefulPartitionedCall/Postprocessor/Slice","StatefulPartitionedCall/Postprocessor/ExpandDims_1"],centernet512fpn:["Identity_4:0","Identity:0","Identity_2:0"]};async function jo(a){let e=Object.assign({},Lo,a);const t=new Ho(e);return await t.load(),t}function Ro(a){return new Promise(function(e,t){a||e({status:!1,msg:"please provide a valid video element"}),a.width=a.width||640,a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height="20px",navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"user"}}).then(s=>{window.localStream=s,a.srcObject=s,a.onloadedmetadata=()=>{a.height=a.width*(a.videoHeight/a.videoWidth),a.style.height=parseInt(a.style.width)*(a.videoHeight/a.videoWidth).toFixed(2)+"px",a.play(),e({status:!0,msg:"webcam successfully initiated."})}}).catch(function(s){e({status:!1,msg:s})})})}async function Bo(){if(window.localStream)window.localStream.getTracks().forEach(a=>(a.stop(),!0));else return!1}class Ho{constructor(e){this.modelPath=e.basePath+e.modelType+"/"+(Fo[e.modelSize]||"base")+"/model.json ",this.modelParams=e}async load(){this.fps=0,this.model=await Co(this.modelPath);const e=na([1,300,300,3],"int32"),t=await this.model.executeAsync(e,Jt[this.modelParams.modelType]);t.map(async s=>await s.data()),t.map(async s=>s.dispose()),Je(e)}async detect(e){let t=Date.now();const[s,i]=Wo(e),n=Yt(this.modelParams.imageScaleFactor,s,this.modelParams.outputStride),o=Yt(this.modelParams.imageScaleFactor,i,this.modelParams.outputStride),u=W(()=>{const p=Un(e);return this.modelParams.flipHorizontal?p.reverse(1).resizeBilinear([n,o]).expandDims(0).toInt():p.resizeBilinear([n,o]).expandDims(0).toInt()}),l=this;return this.model.executeAsync(u,Jt[this.modelParams.modelType]).then(function(p){u.dispose();let m=[];if(l.modelParams.modelType==="centernet512fpn"){const d=p[0].dataSync(),f=p[1].arraySync(),b=p[2].dataSync();Je(p),m=l.buildDetectObjectsCenternet(i,s,f[0],d,b),console.log(m)}else{const d=p[0].dataSync(),f=p[1].dataSync();Je(p);const[b,N]=qo(d,p[0].shape[1],p[0].shape[2]),v=zn();xt("cpu");const R=W(()=>{const x=Cn(f,[p[1].shape[1],p[1].shape[3]]);return Ee.nonMaxSuppression(x,b,l.modelParams.maxNumBoxes,l.modelParams.iouThreshold,l.modelParams.scoreThreshold)}),J=R.dataSync();R.dispose(),xt(v),m=l.buildDetectedObjects(i,s,f,b,J,N)}let h=Date.now();return l.fps=Math.round(1e3/(h-t)),m})}buildDetectedObjects(e,t,s,i,n,o){const u=n.length,l=[];for(let p=0;p<u;p++){const m=[];for(let v=0;v<4;v++)m[v]=s[n[p]*4+v];const h=m[0]*t,d=m[1]*e,f=m[2]*t,b=m[3]*e;m[0]=d,m[1]=h,m[2]=b-d,m[3]=f-h;const N=Math.round(o[n[p]])+1;l.push({bbox:m,class:N,label:this.modelParams.labelMap[N],score:i[n[p]].toFixed(2)})}return l}buildDetectObjectsCenternet(e,t,s,i,n){const o=[];for(let u=0;u<i.length;u++){const l=s[u],p=l[0]*t,m=l[1]*e,h=l[2]*t,d=l[3]*e;l[0]=m,l[1]=p,l[2]=d-m,l[3]=h-p;const f=Math.round(n[u])+1;o.push({bbox:l,class:f,label:this.modelParams.labelMap[f],score:i[u].toFixed(2)})}return o.slice(0,10)}getFPS(){return this.fps}setModelParameters(e){this.modelParams=Object.assign({},this.modelParams,e)}getModelParameters(){return this.modelParams}roundRect(e,t,s,i,n,o,u,l){if(typeof l>"u"&&(l=!0),typeof o>"u"&&(o=5),typeof o=="number")o={tl:o,tr:o,br:o,bl:o};else{var p={tl:0,tr:0,br:0,bl:0};for(var m in p)o[m]=o[m]||p[m]}e.beginPath(),e.moveTo(t+o.tl,s),e.lineTo(t+i-o.tr,s),e.quadraticCurveTo(t+i,s,t+i,s+o.tr),e.lineTo(t+i,s+n-o.br),e.quadraticCurveTo(t+i,s+n,t+i-o.br,s+n),e.lineTo(t+o.bl,s+n),e.quadraticCurveTo(t,s+n,t,s+n-o.bl),e.lineTo(t,s+o.tl),e.quadraticCurveTo(t,s,t+o.tl,s),e.closePath(),u&&e.fill(),l&&e.stroke()}renderPredictions(e,t,s,i){s.clearRect(0,0,t.width,t.height),t.width=i.width,t.height=i.height,t.style.height=parseInt(t.style.width)*(i.height/i.width).toFixed(2)+"px",s.save(),this.modelParams.flipHorizontal&&(s.scale(-1,1),s.translate(-i.width,0)),s.drawImage(i,0,0,i.width,i.height),s.restore(),s.font="bold "+this.modelParams.fontSize+"px Arial";const n=this.modelParams.renderThresholds;for(let o=0;o<e.length;o++){const u=e[o];(!n||u.score>n[u.label])&&(s.beginPath(),s.fillStyle="rgba(255, 255, 255, 0.6)",s.fillRect(u.bbox[0]+1,u.bbox[1]+1,u.bbox[2]-1,this.modelParams.fontSize*1.5),s.lineWidth=this.modelParams.bboxLineWidth,this.roundRect(s,u.bbox[0],u.bbox[1],u.bbox[2],u.bbox[3],5,!1,!0),s.strokeStyle=Kt[u.label],s.fillStyle=Kt[u.label],s.stroke(),s.beginPath(),s.arc(u.bbox[0]+u.bbox[2]/2,u.bbox[1]+u.bbox[3]/2,2,0,2*Math.PI),s.fill(),s.stroke(),s.fillText(u.score+" | "+u.label,u.bbox[0]+5,u.bbox[1]+this.modelParams.fontSize*1.1))}s.fillStyle="rgba(255, 255, 255, 0.6)",this.roundRect(s,10,10,this.modelParams.fontSize*4.6,this.modelParams.fontSize+8,5,!0,!1),s.strokeStyle="#374151",s.fillStyle="#374151",s.font="bold "+this.modelParams.fontSize+"px Arial",s.fillText("FPS: "+this.fps,18,this.modelParams.fontSize+12)}dispose(){this.model&&this.model.dispose()}}function Yt(a,e,t){const s=e*a-1;return s-s%t+1}function Wo(a){return a instanceof ia?[a.shape[0],a.shape[1]]:[a.height,a.width]}function qo(a,e,t){const s=[],i=[];for(let n=0;n<e;n++){let o=Number.MIN_VALUE,u=-1;for(let l=0;l<t;l++)a[n*t+l]>o&&(o=a[n*t+l],u=l);s[n]=o,i[n]=u}return[s,i]}const Go={class:"mt-2"},Uo={class:"mb-1 mt-2"},Ko={class:"text-medium-emphasis"},Jo={class:"mt-2"},Yo={class:"text-h4 text-medium-emphasis mt-4"},Zo={key:0,style:{"font-style":"italic","font-size":"1.2em"},class:"mt-3"},Xo=["id"],Qo={key:0},Mo=["innerHTML"],eu={key:1,class:"mt-6"},tu={key:0,class:"mb-4"},au={key:1},su={style:{"font-size":"0.9em"}},ru={class:"mt-4"},nu={class:"text-center",style:{"margin-top":"40px"}},iu={key:0},ou={class:"text-center mt-2",id:"ratingPart"},uu={class:"text-medium-emphasis mt-6"},lu={key:2,class:"custom-bottom-sheet no-print"},pu={class:"sheet-content",style:{"background-color":"rgb(226, 226, 226)"}},mu={key:0,class:"mb-2"},cu={class:"my-1"},du={key:1,class:"mb-2"},hu={class:"my-1"},yu={key:2,class:"sheet-ingredients"},fu={key:0},gu={key:1},bu={key:0,class:"mb-2"},Nu={style:{"font-size":"1.7em","border-radius":"6px","background-color":"#ffffff",color:"#3d3d3d"},class:"px-2"},vu={key:0},Tu={key:1},Su={style:{"background-color":"rgb(203, 203, 204)",display:"flex"}},wu={class:"ml-2",style:{width:"100px","flex-shrink":"0"}},_u={class:"mx-2",style:{flex:"1"}},ku={class:"mr-2",style:{width:"100px","flex-shrink":"0"}},Zt="*",Ou={__name:"MealMaker",setup(a){kt.extend(Ra);const e=Qt(),t=Mt(),{authInfo:s,githubMode:i,lanAddress:n}=Ba(t),o=ea(),l=pt().query.id,p=C(null),m=C(null),h=C(2),d=C([]),f=C(null),b=C(!1),N=C(!1),v=C(null),R=C(null),J=C([]),x=C(!0),he=C(!0),B=C([]),Y=C(!1),q=C(null),se=C(null),Z=C(!1),ue=C([]),M=C(-1),ze=C([]),ke=C(!1),Te=C(!1),We=C(60);mt(async()=>{p.value=null,m.value=null;let y=await t.getAuthInfo();if(await Fe(),await pe(!0),p.value.planned&&!p.value.cooked&&!i.value){let k=y.calendarPlan??{};const w=new Date,E=w.getFullYear(),A=String(w.getMonth()+1).padStart(2,"0"),O=String(w.getDate()).padStart(2,"0");k[`${E}-${A}-${O}`]&&(k[`${E}-${A}-${O}`].type==="RECIPE"&&k[`${E}-${A}-${O}`].recipeId&&k[`${E}-${A}-${O}`].recipeId!==p.value.id||k[`${E}-${A}-${O}`].type==="SCHEDULED"||k[`${E}-${A}-${O}`].type==="OTHER")?ke.value=!0:(Te.value=!0,setTimeout(async()=>{for(let P=0;P<60&&Te.value!==!1;P++){if(We.value--,We.value===0){Te.value=!1,await qe();break}await new Promise(G=>setTimeout(G,1e3))}},100))}const c=localStorage.getItem("timers-"+l);if(c)try{const k=JSON.parse(c);k.forEach(w=>{w.isPaused=!0}),d.value=k.map(w=>({...w,timeoutId:null}))}catch(k){console.error("Timer konnte nicht geladen werden:",k)}}),Ha(()=>{d.value.forEach(y=>clearTimeout(y.timeoutId)),clearTimeout(f.value)}),Wa(d,y=>{const c=y.map(({timeoutId:k,...w})=>w);localStorage.setItem("timers-"+l,JSON.stringify(c))},{deep:!0}),window.addEventListener("message",y=>{var k;const c=y.data;if(!(!c||typeof c!="object")&&(c.type==="speech-commands:ready"&&console.log(`iFrame bereit (${((k=c.vocab)==null?void 0:k.length)||0} WÃ¶rter)`),c.type==="speech-commands:result")){const w=c.scores.find(O=>O.label==="go"),E=c.scores.find(O=>O.label==="one"),A=c.scores.find(O=>O.label==="eight");w&&w.score>=.7&&(Z.value=!0,q.value="HEARING",se.value&&clearTimeout(se.value),se.value=setTimeout(()=>{Z.value=!1,q.value="LISTENING"},2e3)),(E&&E.score>=.8||A&&A.score>=.8)&&Z.value&&(Z.value=!1,q.value="CLOSED",Vt.reduceExecutions("speech-commands",()=>{M.value++,pe(),se.value=setTimeout(()=>{q.value="LISTENING"},1e3)},1e3))}});async function ha(){await fe.planRecipe(s.value.userId,l),await Fe()}async function qe(){const y={cooked:!0};await fe.updateRecipe(s.value.userId,l,y),fe.uploadRecipeToGithub(s.value.userId,null);let c=s.value.calendarPlan;c||(c={});const k=new Date,w=k.getFullYear(),E=String(k.getMonth()+1).padStart(2,"0"),A=String(k.getDate()).padStart(2,"0");c[`${w}-${E}-${A}`]={type:"RECIPE",recipeId:l,recipeTitle:p.value.title,cooked:!0},await Ya.saveCalendarPlan(s.value.userId,c),ke.value=!1,Te.value=!1}const ya=Ke(()=>!B||B.value.length===0?0:B.value.filter(y=>!y.ingredient&&y.duration).reduce((y,c)=>y+c.duration,0)),gt=Ke(()=>!B||B.value.length===0?[]:B.value.filter(y=>!!y.ingredient)),fa=Ke(()=>!B||B.value.length===0?[]:B.value.filter(y=>!y.ingredient));function ga(){const y=[];p.value.ingredients.forEach(c=>{if(c.preparationRequired){let k=c.preparationLongText;const w=m.value.find(E=>c.name===E.name);if(w){let E="";E=w.amount?w.amount+(w.unit?" "+w.unit:"")+" ":"",k?k=k.replace(c.basicName,E+" "+c.basicName):k=E+" "+c.basicName+" vorbereiten."}y.push({name:k,ingredient:!0})}}),p.value.sections.forEach(c=>{c.ingredientsPreparations&&c.ingredientsPreparations.length>0&&c.ingredientsPreparations.forEach(k=>{let w=[],E=k.instruction;for(let A=0;A<c.usedIngredients.length;A++){let O=c.usedIngredients[A];const P=m.value.find(X=>X.name===O.ingredientNameList);let G="";P&&!w.includes(P.name)&&(G=P.amount?P.amount+(P.unit?" "+P.unit:"")+" ":"",w.push(P.name),E=E.replace(O.ingredientNameText,G+" "+O.ingredientNameText))}y.push({name:E,originalName:k.instruction,sectionIndex:c.index-1,duration:k.duration})})}),B.value=y}function ba(){M.value=-1,x.value=!0,pe()}function Na(y){return i.value?"https://mmhhhh.de/data/home/recipes/"+y.id+"/image.jpg":n.value+"api/"+s.value.userId+"/recipes/"+y.id+"/image"}function bt(){window.close(),setTimeout(()=>{document.title="Cookio - Rezeptmanager",o.push("/recipes")},500)}async function va(){const y={preparations:[]};await fe.updateRecipe(s.value.userId,l,y),await Fe(),await pe(!0)}function Ta(y){St(y),pe(!0)}async function Sa(y){const c={rating:y};await fe.updateRecipe(s.value.userId,l,c),await pe()}async function Nt(){if(!i.value){const y={preparations:B.value};await fe.updateRecipe(s.value.userId,l,y),await pe()}}function wa(y){y&&!y.target.closest(".stopwatch-button")&&(M.value>-1&&M.value--,pe())}function vt(y){y&&!y.target.closest(".stopwatch-button")&&(M.value++,pe())}async function Fe(){p.value=await fe.getRecipe(s.value.userId,l),p.value.ingredients=(await fe.getRecipeIngredients(s.value.userId,l)).data,p.value.sections=(await fe.getRecipeSections(s.value.userId,l)).data}async function pe(y=!1){let c=JSON.parse(JSON.stringify(p.value.sections));St(),y&&(p.value.preparations&&p.value.preparations.length>0?B.value=p.value.preparations:ga()),ue.value=[];let k=-1;if(d.value)for(let O=d.value.length-1;O>=0;O--)(d.value[O].remainingSeconds===0||!d.value[O].timerStarted)&&(d.value=d.value.filter(P=>P.id!==d.value[O].id||P.id===d.value[O].id&&d.value[O].timerStarted));const w=[];let E=null,A=0;for(let O=0;O<c.length;O++){let P=c[O],G=P.description,X="",me=Ca(G);if(A=k+me.length,me.forEach((z,$)=>{k++,ue.value.push(z);const D=B.value.find(U=>U.checked&&O===U.sectionIndex&&U.originalName===z);if(M.value>A||M.value>=k)X=X+'<span style="color: #9a9a9a;">'+z+" </span>";else if(M.value+1===k){if(D)X=X+'<span style="color: #9a9a9a;">'+z+" </span>",M.value++;else if(e.smAndDown.value?X=X+'<span style="background-color: #bfe7d2; font-size: 1.4em; box-decoration-break: clone;-webkit-box-decoration-break: clone;" class="pa-2">'+z+" </span> ":X=X+'â–¶&nbsp;<span style="background-color: #bfe7d2; padding-top: 4px; padding-bottom: 4px">'+z+" </span> ",P.timer&&P.timer.length>0)for(let U=0;U<P.timer.length;U++)z.includes(P.timer[U].descriptionText)&&d.value.push({id:O+"-"+U,title:P.timer[U].title,remainingSeconds:P.timer[U].duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:P.timer[U].descriptionTextAfter})}else X=X+z+" "}),G=X,M.value+1>A&&c.length>O+1&&(E=O+1),P.timer&&P.timer.length>0){let z="",$=G;for(let D=0;D<P.timer.length;D++){const ye=P.timer[D].descriptionText,ee=$.indexOf(ye);if(ee===-1)continue;z+=$.slice(0,ee);const Q=`<span class="pa-1 stopwatch-button" style="cursor: pointer; background-color: rgba(187,187,187,0.66); border: rgba(41,56,80,0.49) solid 3px; border-radius: 20px; color: #545454; font-size: 0.9em" data-id="${D}" data-sectionid="${O}"> â± ${ye}</span>`;z+=Q,$=$.slice(ee+ye.length)}z+=$,G=z}N.value||P.ingredientsPreparations.forEach(z=>{B.value.find(D=>D.checked&&O===D.sectionIndex&&D.originalName===z.instruction)&&(G=G.replace(z.instruction,'<span style="text-decoration-line: line-through;text-decoration-style: solid;text-decoration-thickness: 2px;text-underline-offset: 4px;">'+z.instruction+"</span>"))}),P.usedIngredients.forEach(z=>{const $=m.value.find(U=>U.name===z.ingredientNameList);let D="";$&&!w.includes($.name)&&(D=$.amount?$.amount+($.unit?" "+$.unit:"")+" ":"",w.push($.name)),G=G.replace(z.ingredientNameText,"<b>"+D+z.ingredientNameText+"</b>")}),P.description=G}M.value>A-1&&(x.value=!1),ze.value=c,he.value||setTimeout(()=>{document.getElementById("section-"+E).scrollIntoView({behavior:"smooth",block:"start"})},200),he.value=!1,document.title=p.value.title+" - Cookio"}function _a(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"start"},Zt),Y.value=!0,q.value="LISTENING"}function ka(){document.getElementById("scFrame").contentWindow.postMessage({type:"speech-commands:control",action:"stop"},Zt),Y.value=!1,q.value=null}function Oa(y){v.value(y)}function Tt(){N.value=!N.value,pe()}function St(y){y&&(h.value=y);let c=p.value.portions?p.value.portions:2;m.value=[],p.value.ingredients.forEach(k=>{m.value.push({name:k.name,unit:k.unit,amount:Math.ceil(k.amount/c*h.value)})})}function Ia(y){const c=y.target.closest(".stopwatch-button");if(c){const k=c.dataset.id,w=c.dataset.sectionid,E=parseInt(k,10),A=parseInt(w,10),O=p.value.sections[A].timer[E];d.value.push({id:A+"-"+E,title:O.title,remainingSeconds:O.duration*60,timerStarted:!1,isPaused:!1,timeoutId:null,descriptionTextAfter:O.descriptionTextAfter})}}const Ea=y=>{const c=kt.duration(y*1e3),k=String(c.minutes()).padStart(2,"0"),w=String(c.seconds()).padStart(2,"0");return`${k}:${w}`};function Aa(y){d.value=d.value.filter(c=>c.id!==y)}const Ge=y=>{y.isPaused||y.remainingSeconds<=0||d.value.find(c=>c.id===y.id)&&(y.remainingSeconds--,y.remainingSeconds<=0&&(J.value.push(y),R.value(J.value).then(()=>{J.value=[],d.value=d.value.filter(c=>c.remainingSeconds>0)})),y.remainingSeconds>0?y.timeoutId=setTimeout(()=>Ge(y),1e3):y.timeoutId=null)},$a=y=>{clearTimeout(y.timeoutId),y.timerStarted=!0,y.isPaused=!1,y.timeoutId=setTimeout(()=>Ge(y),1e3)},Da=y=>{y.isPaused=!y.isPaused,!y.isPaused&&y.remainingSeconds>0&&(y.timeoutId=setTimeout(()=>Ge(y),1e3))},Pa=y=>{y.remainingSeconds=y.remainingSeconds+60},za=y=>{const c=y.remainingSeconds-60;y.remainingSeconds=Math.max(c,0)};function Ca(y,c=[]){const k=["ca.","etc.","ggf.","bspw.","bzw.","vgl.","Dr.","Prof.","Nr.","Stk.","Abs.","Art.","Sek.","Std.","Min.","z. B.","u. a.","i. d. R.","z. T.","sog."],w=D=>D.toLowerCase().replace(/[.\s]/g,""),E=new Set([...k,...c].map(w)),A=D=>D>="0"&&D<="9",O=D=>/\s/.test(D),P=D=>/[)"'\]\}Â»â€]/.test(D),G=y.length,X=[];let me="",z=0;function $(D){const U=Math.max(0,D-15),ye=w(y.slice(U,D));for(const ee of E)if(ye.endsWith(ee))return!0;if(y[D]==="."){let ee=D+1;for(;ee<G&&O(y[ee]);)ee++;if(ee+1<G&&/[A-Za-zÃ„Ã–ÃœÃ¤Ã¶Ã¼]/.test(y[ee])&&y[ee+1]===".")return!0}return!1}for(;z<G;){const D=y[z];if(me+=D,D==="."||D==="!"||D==="?"){const U=y[z-1]||"",ye=y[z+1]||"";if(!(D==="."&&A(U)&&A(ye))&&!$(z)){let Q=z+1;for(;Q<G&&(P(y[Q])||y[Q]==="*");)me+=y[Q],Q++;const $e=me.trim();for($e&&X.push($e),me="";Q<G&&O(y[Q]);)Q++;z=Q;continue}}z++}return me.trim()&&X.push(me.trim()),X}const Ae=C(null),Ue=qa(null),Se=C(!1),xa={flipHorizontal:!0,maxNumBoxes:2,scoreThreshold:.6,iouThreshold:.5};async function Va(){if(!await Ro(Ae.value))throw new Error("Kamerazugriff verweigert.");await new Promise(c=>{if(Ae.value.readyState>=2)return c();Ae.value.onloadeddata=()=>c()})}async function La(){Ue.value=await jo(xa)}async function wt(){if(!Se.value)return;const y=await Ue.value.detect(Ae.value);y.length>0&&(y.filter(c=>c.label==="open"&&c.score>.8).length>0&&(Z.value=!0,q.value="OPEN",se.value&&clearTimeout(se.value),se.value=setTimeout(()=>{Z.value=!1,q.value="LISTENING"},2e3)),y.filter(c=>c.label==="closed"&&c.score>.8).length>0&&Z.value&&(Z.value=!1,q.value="CLOSED",Vt.reduceExecutions("recognition-pinch",()=>{M.value++,pe(),se.value=setTimeout(()=>{q.value="LISTENING"},1e3)},1e3),console.log("preds",y))),await new Promise(c=>setTimeout(c,200)),Se.value&&wt()}async function Fa(){if(!Se.value){q.value="LISTENING";try{await Va(),Ue.value||await La(),Se.value=!0,wt()}catch(y){console.error(y)}}}function _t(){q.value=null,Se.value&&(Se.value=!1,Bo(Ae.value))}return Ga(()=>{_t()}),(y,c)=>{const k=H("v-app-bar-nav-icon"),w=H("v-icon"),E=H("v-list-item-title"),A=H("v-list-item"),O=H("v-divider"),P=H("v-chip"),G=H("v-list"),X=H("v-menu"),me=H("v-app-bar"),z=H("v-alert"),$=H("v-btn"),D=H("v-img"),U=H("v-checkbox"),ye=H("v-rating"),ee=H("v-container"),Q=H("v-col"),$e=H("v-row"),ja=H("v-table");return _(),L("div",null,[g(me,{collapse:"",elevation:0,color:"#6969695A",class:"no-print"},{prepend:S(()=>[g(X,null,{activator:S(({props:T})=>[g(k,Ua(Ka(T)),null,16),I("div",null,[q.value==="OPEN"?(_(),te(w,{key:0,icon:"mdi-hand-back-left-outline",size:"30"})):V("",!0),q.value==="HEARING"?(_(),te(w,{key:1,icon:"mdi-ear-hearing",size:"30"})):V("",!0),q.value==="CLOSED"?(_(),te(w,{key:2,icon:"mdi-check-decagram-outline",size:"30"})):V("",!0),q.value==="LISTENING"?(_(),te(w,{key:3,icon:"mdi-record-rec",size:"30"})):V("",!0)])]),default:S(()=>[g(G,{class:"mt-2"},{default:S(()=>[g(A,{onClick:Tt},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-knife",size:"20"}),j(" Schnibbelmodus "+re(N.value?"beenden":""),1)]),_:1})]),_:1}),Y.value?V("",!0):(_(),te(A,{key:0,onClick:c[0]||(c[0]=T=>_a())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-microphone-message",size:"20"}),c[12]||(c[12]=j(" Sprachsteuerung aktivieren",-1))]),_:1})]),_:1})),Y.value?(_(),te(A,{key:1,onClick:c[1]||(c[1]=T=>ka())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-microphone-message-off",size:"20"}),c[13]||(c[13]=j(" Sprachsteuerung beenden",-1))]),_:1})]),_:1})):V("",!0),Se.value?V("",!0):(_(),te(A,{key:2,onClick:c[2]||(c[2]=T=>Fa())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-hand-okay",size:"20"}),c[14]||(c[14]=j(" Gestensteuerung aktivieren",-1))]),_:1})]),_:1})),Se.value?(_(),te(A,{key:3,onClick:c[3]||(c[3]=T=>_t())},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-hand-okay",size:"20"}),c[15]||(c[15]=j(" Gestensteuerung beenden",-1))]),_:1})]),_:1})):V("",!0),g(A,{onClick:c[4]||(c[4]=T=>Oa(we(l)))},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-truck",size:"20"}),c[16]||(c[16]=j(" Zutaten einkaufen",-1))]),_:1})]),_:1}),we(i)?V("",!0):(_(),te(A,{key:4,onClick:c[5]||(c[5]=T=>ha(p.value)),disabled:p.value.planned},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-bowl-mix",size:"20"}),c[17]||(c[17]=j(" Einplanen",-1))]),_:1})]),_:1},8,["disabled"])),g(A,{onClick:ba,disabled:M.value===-1},{default:S(()=>[g(E,null,{default:S(()=>[g(w,{icon:"mdi-backup-restore",size:"20"}),c[18]||(c[18]=j(" Fortschritt zurÃ¼cksetzen",-1))]),_:1})]),_:1},8,["disabled"]),g(O),g(A,null,{default:S(()=>[I("div",Go,[g(w,{icon:"mdi-account-group",size:"20"}),c[19]||(c[19]=j(" Portionen ",-1))]),I("div",Uo,[(_(),L(Oe,null,Ie([1,2,3,4,5,6],T=>I("span",{key:T,class:"ml-1"},[g(P,{color:T===h.value?"indigo":null,"prepend-icon":"mdi-account",onClick:ce=>Ta(T)},{default:S(()=>[j(re(T),1)]),_:2},1032,["color","onClick"])])),64))])]),_:1})]),_:1})]),_:1})]),_:1}),p.value&&p.value.draftInProgress?(_(),te(z,{key:0,type:"warning",color:"rgb(169, 209, 141)",onClick:Fe,style:{cursor:"pointer"},class:"mb-2"},{default:S(()=>[...c[20]||(c[20]=[j("Ein Entwurf wird gerade verarbeitet und anschlieÃŸend Ã¼bernommen. Bitte hier klicken um zu Aktualisieren.",-1)])]),_:1})):V("",!0),p.value?(_(),te(ee,{key:1,class:"pt-0"},{default:S(()=>[I("div",null,[I("div",Ko,[g($,{variant:"plain","prepend-icon":"mdi-arrow-left",onClick:bt},{default:S(()=>[...c[21]||(c[21]=[j("ZurÃ¼ck",-1)])]),_:1})])]),I("div",Jo,[!p.value.imageInProgress&&p.value.imageUploaded?(_(),te(D,{key:0,height:"200",src:Na(p.value),color:"grey",cover:""},null,8,["src"])):V("",!0),I("div",Yo,re(p.value.title),1)]),N.value?V("",!0):(_(),L("div",{key:0,class:"mt-6",onClick:vt},[p.value.preheat?(_(),L("div",Zo,re(p.value.preheat),1)):V("",!0),(_(!0),L(Oe,null,Ie(ze.value,(T,ce)=>(_(),L("div",{key:T.index},[I("div",null,[I("h2",{style:{color:"dimgray"},class:"pt-8",id:"section-"+ce},[T.sectionTitle.startsWith(T.index)?V("",!0):(_(),L("span",Qo,re(T.index),1)),j(" "+re(T.sectionTitle),1)],8,Xo)]),I("div",{style:{"font-size":"1.2em"},class:"mt-1",innerHTML:T.description,onClick:Ia,id:"sectionPart"},null,8,Mo)]))),128))])),N.value?(_(),L("div",eu,[c[24]||(c[24]=I("h2",null,"Vorbereitungen",-1)),we(i)?V("",!0):(_(),L("div",tu,[g($,{onClick:va,variant:"plain",rounded:"",style:{"font-size":"0.7em"}},{default:S(()=>[...c[22]||(c[22]=[j("ZurÃ¼cksetzen",-1)])]),_:1})])),c[25]||(c[25]=I("h3",null,"Zutatenvorbereitungen",-1)),we(gt).length===0?(_(),L("div",au," Keine Vorbereitungen nÃ¶tig. ")):V("",!0),(_(!0),L(Oe,null,Ie(we(gt),T=>(_(),L("div",{class:"mt-1",key:T.name},[g(U,{modelValue:T.checked,"onUpdate:modelValue":ce=>T.checked=ce,"hide-details":"auto",density:"comfortable",label:T.name,onChange:Nt},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),c[26]||(c[26]=I("h3",{class:"mt-3"},"Rezeptvorbereitungen",-1)),I("span",su,"Dauer: "+re(we(ya))+" Min.",1),(_(!0),L(Oe,null,Ie(we(fa),T=>(_(),L("div",{class:"mt-1",key:T.name},[g(U,{modelValue:T.checked,"onUpdate:modelValue":ce=>T.checked=ce,"hide-details":"auto",density:"comfortable",label:T.name,onChange:Nt},null,8,["modelValue","onUpdate:modelValue","label"])]))),128)),I("div",ru,[g($,{onClick:Tt,color:"primary",variant:"outlined",rounded:""},{default:S(()=>[...c[23]||(c[23]=[j("Schnibbelmodus beenden",-1)])]),_:1})])])):V("",!0),I("div",nu,[we(i)?V("",!0):(_(),L("div",iu,[c[27]||(c[27]=I("span",{style:{"font-size":"1.6em"}},"Wie gut hat das Essen geschmeckt?",-1)),I("div",ou,[g(ye,{"onUpdate:modelValue":[Sa,c[6]||(c[6]=T=>p.value.rating=T)],hover:"",length:"5",size:"30",modelValue:p.value.rating,"active-color":"primary"},null,8,["modelValue"])])])),I("div",uu,[g($,{variant:"text","prepend-icon":"mdi-arrow-left",style:{"font-size":"1.1em"},onClick:bt},{default:S(()=>[...c[28]||(c[28]=[j("ZurÃ¼ck zur Ãœbersicht",-1)])]),_:1})])]),c[29]||(c[29]=I("div",{style:{height:"600px"}},null,-1))]),_:1})):V("",!0),m.value?(_(),L("div",lu,[I("div",pu,[Te.value?(_(),L("div",mu,[I("div",cu,[g($e,{align:"center"},{default:S(()=>[g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...c[30]||(c[30]=[j(" Das Rezept ist fÃ¼r heute geplant. Soll es auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:c[7]||(c[7]=T=>Te.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...c[31]||(c[31]=[j(" Nein ",-1)])]),_:1}),g($,{onClick:qe,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[j(" Ja ("+re(We.value)+") ",1)]),_:1})]),_:1})]),_:1})])])):V("",!0),ke.value?(_(),L("div",du,[I("div",hu,[g($e,{align:"center"},{default:S(()=>[g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[...c[32]||(c[32]=[j(" Es wurde ein anderes Rezept geplant. Soll stattdessen dieses auf 'Zubereitet' gesetzt werden? ",-1)])]),_:1}),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:c[8]||(c[8]=T=>ke.value=!1),"prepend-icon":"mdi-close",class:"mr-2",elevation:"0"},{default:S(()=>[...c[33]||(c[33]=[j(" Nein ",-1)])]),_:1}),g($,{onClick:qe,"prepend-icon":"mdi-check",class:"mr-2",elevation:"0",color:"rgb(107, 142, 181)"},{default:S(()=>[...c[34]||(c[34]=[j(" Ja ",-1)])]),_:1})]),_:1})]),_:1})])])):V("",!0),b.value?(_(),L("div",yu,[g(ee,{"max-width":"400"},{default:S(()=>[g(ja,null,{default:S(()=>[I("tbody",null,[(_(!0),L(Oe,null,Ie(m.value,T=>(_(),L("tr",{key:T.name},[I("td",null,[T.amount?(_(),L("span",fu,re(T.amount),1)):V("",!0),c[35]||(c[35]=j()),T.unit?(_(),L("span",gu,re(T.unit),1)):V("",!0)]),I("td",null,re(T.name),1)]))),128))])]),_:1})]),_:1})])):V("",!0),I("div",null,[d.value&&d.value.length>0?(_(),L("div",bu,[I("div",null,[g($,{variant:"text",elevation:"0",disabled:"","prepend-icon":"mdi-timer-play-outline"},{default:S(()=>[...c[36]||(c[36]=[j("Stoppuhren",-1)])]),_:1})]),(_(!0),L(Oe,null,Ie(d.value,T=>(_(),L("div",{key:T.title,class:"my-1"},[g(O,{class:"mb-1"}),g($e,{align:"center"},{default:S(()=>[g($,{icon:"mdi-close",onClick:ce=>Aa(T.id),variant:"text"},null,8,["onClick"]),g(Q,{class:"text-left",style:{"font-size":"1.2em","font-weight":"400","line-height":"1.1 !important"}},{default:S(()=>[j(re(T.title),1)]),_:2},1024),g(Q,{class:"d-flex align-center justify-end"},{default:S(()=>[g($,{onClick:ce=>za(T),icon:"mdi-minus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),g($,{onClick:ce=>Pa(T),icon:"mdi-plus-circle-outline",class:"mr-2",elevation:"0"},null,8,["onClick"]),I("span",Nu,re(Ea(T.remainingSeconds)),1),T.timerStarted?V("",!0):(_(),te($,{key:0,onClick:ce=>$a(T),icon:"mdi-play-circle-outline",class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0"},null,8,["onClick"])),T.timerStarted?(_(),te($,{key:1,onClick:ce=>Da(T),class:"ml-2",color:"rgb(152, 198, 226)",elevation:"0",icon:""},{default:S(()=>[T.isPaused?(_(),L("span",vu,[g(w,{icon:"mdi-play-circle-outline"})])):V("",!0),T.isPaused?V("",!0):(_(),L("span",Tu,[g(w,{icon:"mdi-pause-circle-outline"})]))]),_:2},1032,["onClick"])):V("",!0)]),_:2},1024)]),_:2},1024)]))),128))])):V("",!0),I("div",Su,[I("span",wu,[g($,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:wa,elevation:"0","prepend-icon":"mdi-arrow-left-top"})]),I("span",_u,[g($,{color:"rgb(191, 231, 210)",style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",disabled:!x.value,onClick:vt,elevation:"0","prepend-icon":"mdi-skip-forward"},{default:S(()=>[...c[37]||(c[37]=[j("NÃ¤chster Schritt",-1)])]),_:1},8,["disabled"])]),I("span",ku,[g($,{style:{width:"100%"},"min-height":"60",class:"my-2",variant:"elevated",onClick:c[9]||(c[9]=T=>b.value=!b.value),elevation:"0","prepend-icon":"mdi-food-apple-outline"})])])])])])):V("",!0),c[38]||(c[38]=I("div",{style:{display:"none"}},[I("iframe",{id:"scFrame",src:"/tfjs.html",allow:"microphone"})],-1)),g(Za,{onResult:c[10]||(c[10]=T=>v.value=T)}),g(jn,{onResult:c[11]||(c[11]=T=>R.value=T)}),I("video",{ref_key:"videoEl",ref:Ae,autoplay:"",playsinline:"",muted:"",style:{display:"none"}},null,512)])}}},Iu=Xt(Ou,[["__scopeId","data-v-c739d954"]]),zu={__name:"index",setup(a){const e=pt(),t=Ja();C(!1);const s=e.query.id;return mt(async()=>{s||t.push("/recipes")}),(i,n)=>(_(),te(Iu))}};export{zu as default};
